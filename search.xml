<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[13.库和包]]></title>
    <url>%2F2019%2F08%2F11%2F13.%E5%BA%93%E5%92%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 1.一个string类型的值在底层是怎样被表达的？ (1).是在底层，一个string类型的值是由一系列相对应的Unicode代码点的UTF-8编码值来表达的。 (2).在Go语言中，一个string类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。前者可以由一个以rune为元素类型的切片来表示，而后者则可以由一个以byte为元素类型的切片代表。 ①.rune是Go语言特有的一个基本数据类型，它的一个值就代表一个字符，即：一个Unicode字符。比如，’G’、’o’、’爱’、’好’、’者’代表的就都是一个Unicode字符。 ②.UTF-8编码方案会把一个Unicode字符编码为一个长度在[1, 4]范围内的字节序列。所以，一个rune类型的值也可以由一个或多个字节来代表。 ③.一个rune类型的值在底层其实就是一个UTF-8编码值。前者是（便于我们人类理解的）外部展现，后者是（便于计算机系统理解的）内在表达。 (3).字符串值”Go爱好者”如果被转换为[]rune类型的值的话，其中的每一个字符（不论是英文字符还是中文字符）就都会独立成为一个rune类型的元素值。因此，这段代码打印出的第二行内容就会如下所示：=&gt; runes(char): [&#39;G&#39; &#39;o&#39; &#39;爱&#39; &#39;好&#39; &#39;者&#39;] (4).又由于，每个rune类型的值在底层都是由一个UTF-8编码值来表达的，所以我们可以换一种方式来展现这个字符序列：=&gt; runes(hex): [47 6f 7231 597d 8005] 两个十六进制数47和6f代表的整数都比较小，它们分别表示字符’G’和’o’。因为它们都是英文字符，所以对应的UTF-8编码值用一个字节表达就足够了。 而后三个十六进制数7231、597d和8005都相对较大，它们分别表示中文字符’爱’、’好’和’者’。这些中文字符对应的UTF-8编码值，都需要使用三个字节来表达。 (5).我们还可以进一步地拆分，把每个字符的UTF-8编码值都拆成相应的字节序列：=&gt; bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85] (6).对于一个多字节的UTF-8编码值来说，我们可以把它当做一个整体转换为单一的整数，也可以先把它拆成字节序列，再把每个字节分别转换为一个整数，从而得到多个整数。这两种表示法展现出来的内容往往会很不一样。比如，对于中文字符’爱’来说，它的UTF-8编码值可以展现为单一的整数7231，也可以展现为三个整数，即：e7、88和b1。 (7).总之，一个string类型的值会由若干个Unicode字符组成，每个Unicode字符都可以由一个rune类型的值来承载。这些字符在底层都会被转换为UTF-8编码值，而这些UTF-8编码值又会以字节序列的形式表达和存储。因此，一个string类型的值在底层就是一个能够表达若干个UTF-8编码值的字节序列。 (8).如果我们想得到其中某个Unicode字符对应的UTF-8编码值的宽度，就可以用下一个字符的索引值减去当前字符的索引值。123456789str := &quot;Go爱好者&quot;for i, c := range str &#123; fmt.Printf(&quot;%d: %q [% x] [% x]\n&quot;, i, c, []byte(string(c)), c)&#125;0: &apos;G&apos; [47] [ 47]1: &apos;o&apos; [6f] [ 6f]2: &apos;爱&apos; [e7 88 b1] [ 7231]5: &apos;好&apos; [e5 a5 bd] [ 597d]8: &apos;者&apos; [e8 80 85] [ 8005] 2.与string值相比，strings.Builder类型的值有哪些优势？ (1).已存在的内容不可变，但可以拼接更多的内容；减少了内存分配和内容拷贝的次数；可将内容重置，可重用值。 (2).string类型的值是不可变的。如果我们想获得一个不一样的字符串，那么就只能基于原字符串进行裁剪（使用切片表达式）、拼接(操作符+)等操作， (3).在底层，一个string值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示该string值的长度。 ①.你可以把这块内存的内容看成一个字节数组，而相应的string值则包含了指向字节数组头部的指针值 ②.另一方面，我们在进行字符串拼接的时候，Go语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的string值作为结果返回。 ③.虽然string值在内部持有一个指针值，但其类型仍然属于值类型。 ④.由于string值的不可变，一个string值会在底层与它的所有副本共用同一个字节数组。由于这里的字节数组永远不会被改变，所以这样做是绝对安全的。 (4).与string值相比，Builder值的优势其实主要体现在字符串拼接方面。 ①.Builder值中有一个用于承载内容的容器（以下简称内容容器）。它是一个以byte为元素类型的切片（以下简称字节切片）。由于这样的字节切片的底层数组就是一个字节数组，所以我们可以说它与string值存储内容的方式是一样的。实际上，它们都是通过一个unsafe.Pointer类型的字段来持有那个指向了底层字节数组的指针值的。 ②.对于字节切片本身来说，它可以修改指定的值，但是Builder值并不允许这样做，其中的内容只能够被拼接或者完全重置。这就意味着，已存在于Builder值中的内容是不可变的。因此，我们可以利用Builder值提供的方法拼接更多的内容，而丝毫不用担心这些方法(Builder值拥有的一系列指针方法，包括：Write、WriteByte、WriteRune和WriteString)会影响到已存在的内容。 ③.我们可以通过调用上述方法把新的内容拼接到已存在的内容的尾部（也就是右边）。这时，如有必要，Builder值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。 ④.最后，Builder值是可以被重用的。通过调用它的Reset方法，我们可以让Builder值重新回到零值状态。一旦被重用，Builder值中原有的内容容器会被直接丢弃。之后，它和其中的所有内容，将会被Go语言的垃圾回收器标记并回收掉。 (5).strings.Builder类型在使用上有约束吗？ ①.在已被真正使用后就不可再被复制：使用是指调用了Builder值的拼接方法或扩容方法；复制是指包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。否则，只要在任何副本上调用上述方法就都会引发panic。 12345var builder1 strings.Builderbuilder1.Grow(1)builder3 := builder1//builder3.Grow(1) // 这里会引发panic。_ = builder3 ②.由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。最彻底的解决方案是，绝不共享Builder值以及它的指针值。 ③.虽然已使用的Builder值不能再被复制，但是它的指针值却可以。 123456789f2 := func(bp *strings.Builder) &#123; // 这里虽然不会引发panic，但不是并发安全的。 //如果Builder值被多方同时操作，那么其中的内容就很可能会产生混乱。这就是我们所说的操作冲突和并发安全问题。 (*bp).Grow(1) builder4 := *bp //builder4.Grow(1) // 这里会引发panic。 _ = builder4&#125;f2(&amp;builder1) ④.我们可以在各处分别声明一个Builder值来使用，也可以先声明一个Builder值，然后在真正使用它之前，便将它的副本传到各处。另外，我们还可以先使用再传递，只要在传递之前调用它的Reset方法即可。对于处在零值状态的Builder值，复制不会有任何问题。 123builder1.Reset()builder5 := builder1builder5.Grow(1) // 这里不会引发panic。 3.为什么说strings.Reader类型的值可以高效地读取字符串？ (1).与strings.Builder类型恰恰相反，strings.Reader类型是为了高效读取字符串而存在的。 (2).strings.Reader类型的值可以让我们很方便地读取一个字符串中的内容。在读取的过程中，Reader值会保存已读取的字节的计数（已读计数）。已读计数也代表着下一次读取的起始索引位置。Reader值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取。 (3).这个已读计数也是读取回退和位置设定时的重要依据。虽然它属于Reader值的内部结构，但我们还是可以通过该值的Len方法和Size把它计算出来的。 123var reader1 strings.Reader// 省略若干代码。readingIndex := reader1.Size() - int64(reader1.Len()) // 计算出的已读计数。 (4).Reader值拥有的大部分用于读取的方法都会及时地更新已读计数 ①.比如，ReadByte方法会在读取成功后将这个计数的值加1， ②.又比如，ReadRune方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量。 ③.不过，ReadAt方法算是一个例外。它既不会依据已读计数进行读取，也不会在读取后更新它。 4.bytes.Buffer (1).strings包和bytes包很相似，只不过，strings包主要面向的是Unicode字符和经过UTF-8编码的字符串，而bytes包面对的则主要是字节和字节切片。 (2).bytes.Buffer类型的用途主要是作为字节序列的缓冲区。 (3).与strings.Builder类型一样，bytes.Buffer也是开箱即用的。strings.Builder只能拼接和导出字符串，而bytes.Buffer不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列，bytes.Buffer是集读、写功能于一身的数据类型。。 ①.bytes.Buffer类型同样是使用字节切片作为内容容器的。并且，与strings.Reader类型类似，bytes.Buffer有一个int类型的字段，用于代表已读字节的计数，可以简称为已读计数。 123456var buffer1 bytes.Buffercontents := &quot;Simple byte buffer for marshaling data.&quot;fmt.Printf(&quot;Writing contents %q ...\n&quot;, contents)buffer1.WriteString(contents)fmt.Printf(&quot;The length of buffer: %d\n&quot;, buffer1.Len())fmt.Printf(&quot;The capacity of buffer: %d\n&quot;, buffer1.Cap()) ②.Buffer值的长度是未读内容的长度，而不是已存内容的总长度。它与在当前值之上的读操作和写操作都有关系，并会随着这两种操作的进行而改变，它可能会变得更小，也可能会变得更大。 ③.而Buffer值的容量指的是它的内容容器（也就是那个字节切片）的容量，它只与在当前值之上的写操作有关，并会随着内容的写入而不断增长。 (4).bytes.Buffer类型的值记录的已读计数，在其中起到了怎样的作用？ ①.读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。 ②.写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。 ③.截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。 ④.读回退时，相应方法需要用已读计数记录回退点。 ⑤.重置内容时，相应方法会把已读计数置为0。 ⑥.导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。 ⑦.获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。 (5).bytes.Buffer的绝大多数方法都用到了已读计数，而且都是非用不可。 ①.在读取完成后，它还会及时地更新已读计数：所有名称以Read开头的方法，以及Next方法和WriteTo方法。 ②.在扩容的时候，方法会在必要时，依据已读计数找到未读部分，并把其中的内容拷贝到扩容后内容容器的头部位置。然后，方法将会把已读计数的值置为0，以表示下一次读取需要从内容容器的第一个字节开始：包括了所有名称以Write开头的方法，以及ReadFrom方法。 ③.用于截断内容的方法Truncate， 它会接受一个int类型的参数，这个参数的值代表了：在截断时需要保留头部的多少个字节。不过，需要注意的是，这里说的头部指的并不是内容容器的头部，而是其中的未读部分的头部。头部的起始索引正是由已读计数的值表示的。因此，在这种情况下，已读计数的值再加上参数值后得到的和，就是内容容器新的总长度。 ④.在bytes.Buffer中，用于读回退的方法有UnreadByte和UnreadRune。 这两个方法分别用于回退一个字节和回退一个Unicode字符。退回的前提是，在调用它们之前的那一个操作必须是“读取”，并且是成功的读取，否则这些方法就只能忽略后续操作并返回一个非nil的错误值。 5.bytes.Buffer的扩容策略是怎样的？ (1).如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充，就像下面这样：b.buf = b.buf[:length+need] (2).如果当前内容容器的容量的一半仍然大于或等于其现有长度再加上另需的字节数的和，即：cap(b.buf)/2 &gt;= len(b.buf)+need，那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。这也意味着其中的已读内容，将会全部被未读内容和之后的新内容覆盖掉。这样的复用预计可以至少节省掉一次后续的扩容所带来的内存分配，以及若干字节的拷贝。扩容代码还会把已读计数置为0，并再对内容容器做一下切片操作，以掩盖掉原有的已读内容。 (3).bytes.Buffer中的哪些方法可能会造成内容的泄露？ ①.在bytes.Buffer中，Bytes方法和Next方法都可能会造成内容的泄露。原因在于，它们都把基于内容容器的切片直接返回给了方法的调用方。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>13.库和包</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.go语言测试]]></title>
    <url>%2F2019%2F08%2F11%2F12.go%E8%AF%AD%E8%A8%80%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.Go程序三类测试：功能测试（test）、基准测试（benchmark，也称性能测试），以及示例测试（example）。 (1).一般情况下，一个测试源码文件只会针对于某个命令源码文件，或库源码文件（以下简称被测源码文件）做测试，所以我们总会（并且应该）把它们放在同一个代码包内。 (2).测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀。我们可以依据这些测试函数针对的不同程序实体，把它们分成不同的逻辑组，并且，利用注释以及帮助类的变量或函数来做分割。同时，我们还可以依据被测源码文件中程序实体的先后顺序，来安排测试源码文件中测试函数的顺序。 2.Go语言对测试函数的名称和签名都有哪些规定？ (1).规定 ①.对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。 ②.对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。 ③.对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。 (2).go test命令执行的主要测试流程是什么？ ①.只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行go test命令的时候，其中的测试代码才有可能被运行。 ②.在准备工作顺利完成之后，go test命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。 ③.但是，为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试。 ④.性能测试一般都是串行进行的。下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。 (3).怎样解释功能测试的测试结果？ ①.命令go test puzzlers/article20/q2。go命令通常会缓存程序构建的结果，以便在将来的构建中重用。我们可以通过运行go env GOCACHE命令来查看缓存目录的路径。缓存的数据总是能够正确地反映出当时的各种源码文件、构建环境、编译器选项等等的真实情况。我们并不用在意缓存数据的存在，因为它们肯定不会妨碍go test命令打印正确的测试结果。 (4).怎样解释性能测试的测试结果？ ①.命令：go test -bench=. -run=^$ puzzlers/article20/q3 ②.第一个标记及其值为-bench=.，只有有了这个标记，命令才会进行性能测试。该标记的值.表明需要执行任意名称的性能测试函数 ③.第二个标记及其值是-run=^$，这个标记用于表明需要执行哪些功能测试函数，这同样也是以函数名称为依据的。^$是正则表达式的开头和结尾。该标记的值^$意味着：只执行名称为空的功能测试函数，换句话说，不执行任何功能测试函数。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>12.go语言测试</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.错误以及处理]]></title>
    <url>%2F2019%2F08%2F11%2F11.%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.使用携带range子句的for语句时需要注意哪些细节？ (1).例子： 123456789numbers1 := []int&#123;1, 2, 3, 4, 5, 6&#125;for i := range numbers1 &#123;&#125;numbers2 := [...]int&#123;1, 2, 3, 4, 5, 6&#125;for i, e := range numbers2 &#123;&#125; (2).当for语句被执行的时候，在range关键字右边的numbers1会先被求值。这个位置上的代码被称为range表达式。range表达式的结果值可以是数组、数组的指针、切片、字符串、字典或者允许接收操作的通道，并且结果值只能有一个。 (3).对于不同种类的range表达式结果值，for语句的迭代变量的数量可以有所不同。当只有一个迭代变量的时候，数组、数组的指针、切片和字符串的元素值都是无处安放的，我们只能拿到按照从小到大顺序给出的一个个索引值。 (4). 需要注意两点： range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代； range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值。切片拿到的指针副本、数组拿到的是值 2.switch语句 (1).case表达式的所有子表达式的结果值都是要与switch表达式的结果值判等的，因此它们的类型必须相同或者能够都统一到switch表达式的结果类型。如果无法做到，那么这条switch语句就不能通过编译。 (2).同一条switch语句中的所有case表达式的子表达式的结果值不能重复，不过好在这只是对于由字面量直接表示的子表达式而言的。 (3).普通case子句的编写顺序很重要，最上边的case子句中的子表达式总是会被最先求值，在判等的时候顺序也是这样。因此，如果某些子表达式的结果值有重复并且它们与switch表达式的结果值相等，那么位置靠上的case子句总会被选中。 3.错误处理 (1).例子 1234567891011121314151617181920func echo(request string) (response string, err error) &#123; if request == &quot;&quot; &#123; err = errors.New(&quot;empty request&quot;) return &#125; response = fmt.Sprintf(&quot;echo: %s&quot;, request) return&#125;func main() &#123; for _, req := range []string&#123;&quot;&quot;, &quot;hello!&quot;&#125; &#123; fmt.Printf(&quot;request: %s\n&quot;, req) resp, err := echo(req) if err != nil &#123; fmt.Printf(&quot;error: %s\n&quot;, err) continue &#125; fmt.Printf(&quot;response: %s\n&quot;, resp) &#125;&#125; ①.每次调用echo函数之后都会把它返回的结果值赋给变量resp和err，并且总是先检查err的值是否“不为nil”，如果是，就打印错误信息，否则就打印常规的响应信息。 ②.卫述语句：它就是被用来检查后续操作的前置条件并进行相应处理的语句。 ③.go语言的风格就是满屏幕的卫述语句 (2).errors包 12345678910package errorsfunc New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; errors.New方法返回error类型值。该值的静态类型当然是error，而动态类型则是一个在errors包中的，包级私有的类型*errorString。 errorString类型拥有的一个指针方法实现了error接口中的Error方法。即*errorString类型实现了error接口 而对于error类型值，它的字符串表示形式则取决于它的Error方法。 (3).对于具体错误的判断，Go语言中都有哪些惯用法？由于error是一个接口类型，所以即使同为error类型的错误值，它们的实际类型也可能不同。这个问题还可以换一种问法，即：怎样判断一个错误值具体代表的是哪一类错误？ ①.对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断； ②.对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断； ③.对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。 4.怎样根据实际情况给予恰当的错误值？ (1).构建错误值体系的基本方式有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。 ①.错误类型体系：由于在Go语言中实现接口是非侵入式的，所以我们可以做得很灵活。比如，在标准库的net代码包中，有一个名为Error的接口类型。它算是内建接口类型error的一个扩展接口，因为error是net.Error的嵌入接口。net.Error接口除了拥有error接口的Error方法之外，还有两个自己声明的方法：Timeout和Temporary。 ②.net包中有很多错误类型都实现了net.Error接口，比如： *net.OpError； *net.AddrError； net.UnknownNetworkError等等。 ③.你可以把这些错误类型想象成一棵树，内建接口error就是树的根，而net.Error接口就是一个在根上延伸的第一级非叶子节点。 同时，你也可以把这看做是一种多层分类的手段。当net包的使用者拿到一个错误值的时候，可以先判断它是否是net.Error类型的，也就是说该值是否代表了一个网络相关的错误。 如果是，那么我们还可以再进一步判断它的类型是哪一个更具体的错误类型，这样就能知道这个网络相关的错误具体是由于操作不当引起的，还是因为网络地址问题引起的，又或是由于网络协议不正确引起的。 (2).这些错误类型的值之间还可以有另外一种关系，即：链式关系。 ①.比如说，使用者调用net.DialTCP之类的函数时，net包中的代码可能会返回给他一个*net.OpError类型的错误值，以表示由于他的操作不当造成了一个错误。 ②.同时，这些代码还可能会把一个*net.AddrError或net.UnknownNetworkError类型的值赋给该错误值的Err字段，以表明导致这个错误的潜在原因。如果，此处的潜在错误值的Err字段也有非nil的值，那么将会指明更深层次的错误原因。如此一级又一级就像链条一样最终会指向问题的根源。 ③.把以上这些内容总结成一句话就是，用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。这是Go语言标准库给予我们的优秀范本，非常有借鉴意义。 如果你不想让包外代码改动你返回的错误值的话，一定要小写其中字段的名称首字母。你可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如编写一个可以返回包级私有的err字段值的公开方法Err。 (3).扁平的错误值列表就要简单得多了。当我们只是想预先创建一些代表已知错误的错误值时候，用这种扁平化的方式就很恰当了。 ①.不过，由于error是接口类型，所以通过errors.New函数生成的错误值只能被赋给变量，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其访问权限只能是公开的。 ②.这就带来了一个问题，如果有恶意代码改变了这些公开变量的值，那么程序的功能就必然会受到影响。因为在这种情况下我们往往会通过判等操作来判断拿到的错误值具体是哪一个错误，如果这些公开变量的值被改变了，那么相应的判等操作的结果也会随之改变。 (4).这里有两个解决方案。 ①.第一个方案是，先私有化此类变量，也就是说，让它们的名称首字母变成小写，然后编写公开的用于获取错误值以及用于判等错误值的函数。 比如，对于错误值os.ErrClosed，先改写它的名称，让其变成os.errClosed，然后再编写ErrClosed函数和IsErrClosed函数。 ②.第二个方案存在于syscall包中。该包中有一个类型叫做Errno，该类型代表了系统调用时可能发生的底层错误。这个错误类型是error接口的实现类型，同时也是对内建类型uintptr的再定义类型。 由于uintptr可以作为常量的类型，所以syscall.Errno自然也可以。syscall包中声明有大量的Errno类型的常量，每个常量都对应一种系统调用错误。syscall包外的代码可以拿到这些代表错误的常量，但却无法改变它们。 我们可以仿照这种声明方式来构建我们自己的错误值列表，这样就可以保证错误值的只读特性了。 5.从panic被引发到程序终止运行的大致过程是什么？ (1).某个函数中的某行代码有意或无意地引发了一个panic。这时，初始的panic详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。 (2).这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。 (3).这里的最外层函数指的是go函数，对于主goroutine来说就是main函数。但是控制权也不会停留在那里，而是被Go语言运行时系统收回。 (4).随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。 (5).解析：panic可能是我们在无意间（或者说一不小心）引发的，比如索引越界。这类panic是真正的、在我们意料之外的程序异常。不过，除此之外，我们还是可以有意地引发panic。 ①.Go语言的内建函数panic是专门用于引发panic的。panic函数使程序开发者可以在程序运行期间报告异常。 ②.注意：这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非nil的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。但是，当一个panic发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃，这显然是致命的。 ③.如果一个panic是我们在无意间引发的，那么其中的值只能由Go语言运行时系统给定。但是，当我们使用panic函数有意地引发一个panic的时候，却可以自行指定其包含的值 6.怎样让panic包含一个值，以及应该让它包含什么样的值？ (1).在调用panic函数时，把某个值作为参数传给该函数就可以了。由于panic函数的唯一一个参数是空接口（也就是interface{}）类型的。但是，我们最好传入error类型的错误值，或者其他的可以被有效序列化的值。这样处理有什么好处： ①.对于fmt包下的各种打印函数来说，error类型值的Error方法与其他类型值的String方法是等价的，它们的唯一结果都是string类型的 ②在程序崩溃的时候，panic包含的那个值字符串表示形式会被打印出来。 7.怎样施加应对panic的保护措施，从而避免程序崩溃？ (1).Go语言的内建函数recover专用于恢复panic，或者说平息运行时恐慌。recover函数无需任何参数，并且会返回一个空接口类型的值。 (2).defer语句就是被用来延迟执行代码的，类似finnally。一个defer语句总是由一个defer关键字和一个调用表达式组成。 注意，被延迟执行的是defer函数，而不是defer语句。1234567891011121314func main() &#123; fmt.Println(&quot;Enter function main.&quot;) //defer语句要写在前面，引发panic之后，没有权限执行这个 defer func()&#123; fmt.Println(&quot;Enter defer function.&quot;) if p := recover(); p != nil &#123; fmt.Printf(&quot;panic: %s\n&quot;, p) &#125; fmt.Println(&quot;Exit defer function.&quot;) &#125;() // 引发panic。 panic(errors.New(&quot;something wrong&quot;)) fmt.Println(&quot;Exit function main.&quot;)&#125; (3).如果一个函数中有多条defer语句，那么那几个defer函数调用的执行顺序是怎样的？ ①.在同一个函数中，defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反。 ②.当一个函数即将结束执行时，其中的写在最下边的defer函数调用会最先执行，其次是写在它上边、与它的距离最近的那个defer函数调用，以此类推，最上边的defer函数调用会最后一个执行。 ③.原理：在defer语句每次执行的时候，Go语言会把它携带的defer函数及其参数值另行存储到一个队列中。这个队列与该defer语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。 ④.在需要执行某个函数中的defer函数调用的时候，Go语言会先拿到对应的队列，然后从该队列中一个一个地取出defer函数及其参数值，并逐个执行调用。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>11.错误以及处理</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.go的同步工具]]></title>
    <url>%2F2019%2F08%2F11%2F10.go%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.go中的编程哲学和并发编程模式 (1).Don’t communicate by sharing memory; share memory by communicating–不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。 ①.通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。 ②.goroutine代表着并发编程模型中的用户级线程。 (2).进程与线程 ①.进程，描述的就是程序的执行过程，是运行着的程序的代表。换句话说，一个进程其实就是某个程序运行时的一个产物。 ②.线程。 首先，线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。 一个进程至少会包含一个线程。如果一个进程只包含了一个线程，那么它里面的所有代码都只会被串行地执行。每个进程的第一个线程都会随着该进程的启动而被创建，它们可以被称为其所属进程的主线程。 相对应的，如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行。除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的。 ③.主线程之外的其他线程都只能由代码显式地创建和销毁。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实地执行我们的指令。 ④.在Go程序当中，Go语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。 (3).用户线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程。 ①.用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。 ②.但是，劣势也是有的，最明显也最重要的一个劣势就是复杂。既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。 (4).Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器 ①.这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）。 ②.其中的M指代的就是系统级线程。而P是一个中介，可以承载若干个G，且能够使这些G适时地与M进行对接，并得到真正运行。 ③.从宏观上说，G和M由于P的存在可以呈现出多对多的关系。当一个正在与某个M对接并运行着的G，需要因某个事件（比如等待I/O或锁的解除）而暂停运行的时候，调度器总会及时地发现，并把这个G与那个M分离开，以释放计算资源供那些等待运行的G使用。 ④.而当一个G需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括M）并安排运行。另外，当M不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个M已无用时，调度器又会负责把它及时地销毁掉。 ⑤.正因为调度器帮助我们做了很多事，所以我们的Go程序才总是能高效地利用操作系统和计算机资源。程序中的所有goroutine也都会被充分地调度，其中的代码也都会被并发地运行，即使这样的goroutine有数以十万计，也仍然可以如此。 (5).什么是主goroutine，它与我们启用的其他goroutine有什么不同？ ①.与一个进程总会有一个主线程类似，每一个独立的Go程序在运行时也总会有一个主goroutine。这个主goroutine会在Go程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。 ②.每条go语句一般都会携带一个函数调用，这个被调用的函数常常被称为go函数。而主goroutine的go函数就是那个作为程序入口的main函数。 主goroutine的重要特性：一旦主goroutine中的代码（也就是main函数中的那些代码）执行完毕，当前的Go程序就会结束运行。 ③.go函数真正被执行的时间，总会与其所属的go语句被执行的时间不同。当程序执行到一条go语句的时候，Go语言的运行时系统，会先试图从某个存放空闲的G的队列中获取一个G（也就是goroutine），它只有在找不到空闲G的情况下才会去创建一个新的G。创建G的成本也是非常低的。 ④.在拿到了一个空闲的G之后，Go语言运行时系统会用这个G去包装当前的那个go函数（或者说该函数中的那些代码），然后再把这个G追加到某个存放可运行的G的队列中。 ⑤.这类队列中的G总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。 ⑥.例子,运行完成后，多数情况下什么也不会输出！主goroutine如果睡眠1s，打印出可能是10个10123456789package mainimport &quot;fmt&quot;func main() &#123; for i := 0; i &lt; 10; i++ &#123; go func() &#123; fmt.Println(i) &#125;() &#125;&#125; (6).怎样才能让主goroutine等待其他goroutine？ 方案：sleep、sync.WaitGroup、chan(使用空结构体struct{}最为介质最合适，它占用的内存空间是0字节，实例struct{}{}共用一份内存)1234567891011121314num := 10sign := make(chan struct&#123;&#125;, num)for i := 0; i &lt; num; i++ &#123; go func() &#123; fmt.Println(i) sign &lt;- struct&#123;&#125;&#123;&#125; &#125;()&#125;// 办法1。//time.Sleep(time.Millisecond * 500)// 办法2。for j := 0; j &lt; num; j++ &#123; &lt;-sign&#125; (7).怎样让我们启用的多个goroutine按照既定的顺序运行？ ①.我们只需要稍微改造一下for语句中的那个go函数，要让它接受一个int类型的参数，并在调用它的时候把变量i的值传进去。只有这样，Go语言才能保证每个goroutine都可以拿到一个唯一的整数。其原因与go函数的执行时机有关。 12345for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; fmt.Println(i) &#125;(i)&#125; ②.建立自旋函数trigger ，让所有goroutine调用，按照 n == i 规定输出 1234567891011121314151617181920var count uint32trigger := func(i uint32, fn func()) &#123; for &#123; if n := atomic.LoadUint32(&amp;count); n == i &#123; fn() atomic.AddUint32(&amp;count, 1) break &#125; time.Sleep(time.Nanosecond) &#125;&#125;for i := uint32(0); i &lt; 10; i++ &#123; go func(i uint32) &#123; fn := func() &#123; fmt.Println(i) &#125; trigger(i, fn) &#125;(i)&#125;trigger(10, func() &#123;&#125;) (8).总结：go函数的实际执行顺序往往与其所属的go语句的执行顺序（或者说goroutine的启用顺序）不同，而且默认情况下的执行顺序是不可预知的。 2.解读Process (1).Go语言并发编程模型中的P，正是goroutine的数量能够数十万计的关键所在。P的数量意味着Go程序背后的运行时系统中，会有多少个用于承载可运行的G的队列存在。每一个队列都相当于一条流水线，它会源源不断地把可运行的G输送给空闲的M，并使这两者对接。 ①.G就是goroutine的缩写，可以被理解为Go语言自己实现的用户级线程。M即为machine的缩写，代表着系统级线程，或者说操作系统内核级别的线程。 ②.一旦对接完成，被对接的G就真正地运行在操作系统的内核级线程之上了。每条流水线之间虽然会有联系，但都是独立运作的。 ③.最大P数量就代表着Go语言运行时系统同时运行goroutine的能力，也可以被视为其中逻辑CPU的最大个数。 3.sync包 (1).相比于Go语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流 ①.一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为竞态条件（race condition），这往往会破坏共享数据的一致性。 ②.共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。 (2).同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。 ①.一个线程在想要访问某一个共享资源的时候，需要先申请对该资源的访问权限，并且只有在申请成功之后，访问才能真正开始。而当线程对共享资源的访问结束时，它还必须归还对该资源的访问权限，若要再次访问仍需申请。 ②.如果针对某个共享资源的访问令牌只有一块，那么在同一时刻，就最多只能有一个线程进入到那个区域，并访问到该资源。 ③.多个并发运行的线程对这个共享资源的访问是完全串行的。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是我刚刚说的，由于要访问到资源而必须进入的那个区域。 ④.临界区：它们可以是一个内含了共享数据的结构体及其方法，也可以是操作同一块共享数据的多个函数。临界区总是需要受到保护的，否则就会产生竞态条件。施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。 (3).在Go语言中，可供我们选择的同步工具并不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称mutex） ①.sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。 123456mu.Lock()_, err := writer.Write([]byte(data))if err != nil &#123;log.Printf(&quot;error: %s [%d]&quot;, err, id)&#125;mu.Unlock() ②.我们使用互斥锁时有哪些注意事项？我们总是应该保证，对于每一个锁定操作，都要有且只有一个对应的解锁操作。在很多时候，利用defer语句进行解锁可以更容易做到这一点。 不要重复锁定互斥锁：一个goroutine对某一个互斥锁的重复锁定，就意味着它自己锁死了自己。不能重入 不要忘记解锁互斥锁，必要时使用defer语句：类似在finnaly中解锁 ** 不要对尚未锁定或者已解锁的互斥锁解锁**：解锁未锁定的互斥锁会立即引发panic。 不要在多个函数之间直接传递互斥锁：sync.Mutex类型的变量是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。并且，原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。如果你把一个互斥锁作为参数值传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。 Go语言中的互斥锁是开箱即用的。换句话说，一旦我们声明了一个sync.Mutex类型的变量，就可以直接使用它了。 ③.读写锁sync.RWMutex与互斥锁有哪些异同？除了读读不阻塞之外，其余都是一样的。不要重复锁定、解锁或忘记解锁 4.条件变量sync.Cond (1).条件变量：条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。 ①.比如说，我们两个人在共同执行一项秘密任务，这需要在不直接联系和见面的前提下进行。我需要向一个信箱里放置情报，你需要从这个信箱中获取情报。这个信箱就相当于一个共享资源，而我们就分别是进行写操作的线程和进行读操作的线程。 ②.如果我在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信箱里没有情报，那也只能先回去了。这就相当于写的线程或读的线程阻塞的情况。 ③.如果信箱里有情报，而你却迟迟未取走，那我就需要每过一段时间带着新情报去检查一次，若发现信箱空了，我就需要及时地把新情报放到里面。另一方面，如果信箱里一直没有情报，那你也要每过一段时间去打开看看，一旦有了情报就及时地取走。这么做是可以的，但就是太危险了，很容易被敌人发现。 ④.各自雇佣了一个不起眼的小孩儿。如果早上七点有一个戴红色帽子的小孩儿从你家楼下路过，那么就意味着信箱里有了新情报。另一边，如果上午九点有一个戴蓝色帽子的小孩儿从我家楼下路过，那就说明你已经从信箱中取走了情报。这两个戴不同颜色帽子的小孩儿就相当于条件变量，在共享资源的状态产生变化的时候，起到了通知的作用。 (2).条件变量怎样与互斥锁配合使用？条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的。 ①.条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast） 类似Java中：await、singal、singalAll ②.我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行(await需要在获取锁的情况下调用，调用后释放锁)。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。 ③.与sync.Mutex类型和sync.RWMutex类型不同，sync.Cond类型并不是开箱即用的。我们只能利用sync.NewCond函数创建它的指针值。这个函数需要一个sync.Locker类型的参数值（互斥锁）。 123var lock sync.RWMutexsendCond := sync.NewCond(&amp;lock)recvCond := sync.NewCond(lock.RLocker()) 这里sendCond使用lock写锁（lock和unlock），recvCond使用lock的读锁(lock.RLocker()调用的是lock中的Rlock和RUnlock) ④.我，现在是一个goroutine（携带的go函数），想要适时地向信箱里放置情报并通知你，应该怎么做呢？ 1234567lock.Lock()for mailbox == 1 &#123; //用for是因为可能存在空唤醒、误报 sendCond.Wait()//这里会放锁&#125;mailbox = 1lock.Unlock()recvCond.Signal()//通知别人 ⑤.另一方面，你现在是另一个goroutine，想要适时地从信箱中获取情报，然后通知我。 1234567lock.RLock()for mailbox == 0 &#123; recvCond.Wait()&#125;mailbox = 0lock.RUnlock()sendCond.Signal() (3).条件变量的Wait方法做了什么？ ①.条件变量的Wait方法主要做了四件事 第一：把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中。 第二：解锁当前的条件变量基于的那个互斥锁(unlock)。 第三：让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个Wait方法的那行代码上。 第四：如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了 (4).条件变量的Signal方法和Broadcast方法有哪些异同？ ①条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的goroutine，而后者的通知却会唤醒所有为此等待的goroutine。条件变量的Wait方法总会把当前的goroutine添加到通知队列的队尾，而它的Signal方法总会从通知队列的队首开始查找可被唤醒的goroutine。所以，因Signal方法的通知而被唤醒的goroutine一般都是最早等待的那一个。 ②.再次强调一下，与Wait方法不同，条件变量的Signal方法和Broadcast方法并不需要在互斥锁的保护下执行。 ③.条件变量的通知具有即时性。也就是说，如果发送通知的时候没有goroutine为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的goroutine只可能被后面的通知唤醒。 5.原子操作 (1).原子操作： ①.对于一个Go程序来说，Go语言运行时系统中的调度器，会恰当地安排其中所有的goroutine的运行。不过，在同一时刻，只可能有少数的goroutine真正地处于运行状态，并且这个数量是固定的。所以，为了公平起见，调度器总是会频繁地换上或换下这些goroutine。 ②.换上的意思是，让一个goroutine由非运行状态转为运行状态，并促使其中的代码在某个CPU核心上执行。 ③.换下的意思正好相反，即：使一个goroutine中的代码中断执行，并让它由运行状态转为非运行状态。这个中断的时机有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。即使这些语句在临界区之内也是如此。所以，我们说，互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）。 ④.真正能够保证原子性执行的只有原子操作（atomic operation）。原子操作在进行的过程中是不允许中断的。在底层，这会由CPU提供芯片级别的支持，所以绝对有效。即使在拥有多CPU核心，或者多CPU的计算机系统中，原子操作的保证也是不可撼动的。 ⑤.这使得原子操作可以完全地消除竞态条件，并能够绝对地保证并发安全性。并且，它的执行速度要比其他的同步工具快得多，通常会高出好几个数量级。不过，正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速。因此，操作系统层面只对针对二进制位或整数的原子操作提供了支持。 (2).sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？ ①.sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称CAS）、加载（load）、存储（store）和交换（swap）。 ②.这些函数针对的数据类型并不多。但是，对这些类型中的每一个，sync/atomic包都会有一套函数给予支持。这些数据类型有：int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。 ③.此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值。 (3).原子操作函数的第一个参数值必须是指针类型 比如，atomic.AddInt32函数的第一个参数，不是int32而是*int32。因为原子操作函数需要的是被操作值的指针，而不是这个值本身； unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。 只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据。 (4).用于原子加法操作的函数可以做原子减法 atomic.AddInt32函数的第二个参数代表差量，它的类型是int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。 对于无符号类型的，比如atomic.AddUint32函数的第二个参数值可以这么给出：^uint32(-N-1)) (5).CAS操作的优势 ①.在进行CAS操作的时候，函数会先判断被操作变量的当前值，是否与我们预期的旧值相等。如果相等，它就把新值赋给该变量，并返回true以表明交换操作已进行；否则就忽略交换操作，并返回false ②.CAS操作并不是单一的操作，而是一种操作组合。可以实现各种操作，比如自旋锁： 1234567for &#123; if atomic.CompareAndSwapInt32(&amp;num2, 10, 0) &#123; fmt.Println(&quot;The second number has gone to zero.&quot;) break &#125; time.Sleep(time.Millisecond * 500)&#125; ③.这在效果上与互斥锁有些类似。不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他的goroutine频繁地改变。— 悲观锁 ④.而for语句加CAS操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，或者说更加宽松的做法。—乐观锁 (6).假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？回答：很有必要。如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的。 (7).由于这里的原子操作函数只支持非常有限的数据类型，所以在很多应用场景下，互斥锁往往是更加适合的。 (8).sync/atomic.Value ①.atomic.Value类型是开箱即用的，它只有两个指针方法——Store和Load。 ②.一旦atomic.Value类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。 读取值：atomic.Value类型属于结构体类型，而结构体类型属于值类型。复制该类型的值会产生一个完全分离的新值。 存储值，有两条强制性的使用规则。第一条规则，不能用原子值存储nil。这里要注意，如果有一个接口类型的变量，它的动态值是nil，但动态类型却不是nil，那么它的值就不等于nil，这样一个变量的值是可以被存入原子值的。第二条规则，我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。 (9).具体的使用建议: 不要把内部使用的原子值暴露给外界。 如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。 如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。 如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。 尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞。 6.sync.WaitGroup (1).sync包的WaitGroup类型：它比通道更加适合实现这种一对多的goroutine协作流程。 ①.sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，也是并发安全的。同时，与我们前面讨论的几个同步工具一样，它一旦被真正使用就不能被复制了。 ②.WaitGroup类型拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值。 ③.一般情况下，我会用这个方法来记录需要等待的goroutine的数量。相对应的，这个类型的Done方法，用于对其所属值中计数器的值进行减一操作。我们可以在需要等待的goroutine中，通过defer语句调用它。 ④.而此类型的Wait方法的功能是，阻塞当前的goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。1234567891011121314151617181920212223242526272829func coordinateWithWaitGroup() &#123; var wg sync.WaitGroup wg.Add(2) num := int32(0) fmt.Printf(&quot;The number: %d [with sync.WaitGroup]\n&quot;, num) max := int32(10) go addNum(&amp;num, 3, max, wg.Done) go addNum(&amp;num, 4, max, wg.Done) wg.Wait()&#125;// addNum 用于原子地增加numP所指的变量的值。func addNum(numP *int32, id, max int32, deferFunc func()) &#123; defer func() &#123; deferFunc() &#125;() for i := 0; ; i++ &#123; currNum := atomic.LoadInt32(numP) if currNum &gt;= max &#123; break &#125; newNum := currNum + 2 time.Sleep(time.Millisecond * 200) if atomic.CompareAndSwapInt32(numP, currNum, newNum) &#123; fmt.Printf(&quot;The number: %d [%d-%d]\n&quot;, newNum, id, i) &#125; else &#123; fmt.Printf(&quot;The CAS operation failed. [%d-%d]\n&quot;, id, i) &#125; &#125;&#125; (2).WaitGroup细节 ①.WaitGroup值是可以被复用的，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由0变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了0。 如果一个此类值的Wait方法在它的某个计数周期中被调用，那么就会立即阻塞当前的goroutine，直至这个计数周期完成。在这种情况下，该值的下一个计数周期，必须要等到这个Wait方法执行结束之后，才能够开始。 ②.两种情况下引发panic 如果我们对它的Add方法的首次调用，与对它的Wait方法的调用是同时发起的，比如，在同时启用的两个goroutine中，分别调用这两个方法，那么就有可能会让这里的Add方法抛出一个panic。所以，虽然WaitGroup值本身并不需要初始化，但是尽早地增加其计数器的值，还是非常有必要的。 如果在一个此类值的Wait方法被执行期间，跨越了两个计数周期，那么就会引发一个panic。在当前的goroutine因调用此类值的Wait方法，而被阻塞的时候，另一个goroutine调用了该值的Done方法，并使其计数器的值变为了0。这会唤醒当前的goroutine，并使它试图继续执行Wait方法中其余的代码。上述过程是正常的，但在这时，又有一个goroutine调用了它的Add方法，并让其计数器的值又从0变为了某个正整数。此时，这里的Wait方法就会立即抛出一个panic。 ③.WaitGroup值的使用禁忌：不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的goroutine中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行！！！，非常重要。 ④.在使用WaitGroup值的时候，我们最好用“先统一Add，再并发Done，最后Wait”的标准模式来构建协作流程。123456789var wg sync.WaitGroupfor i := 1; i &lt;= total; i = i + stride &#123; wg.Add(stride) for j := 0; j &lt; stride; j++ &#123; go addNum(&amp;num, i+j, wg.Done) &#125; wg.Wait()&#125;fmt.Println(&quot;End.&quot;) 7.sync.Once (1).与sync.WaitGroup类型一样，sync.Once类型（以下简称Once类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，所以，复制该类型的值也会导致功能的失效。 (2).Once类型的Do方法只接受一个参数，这个参数的类型必须是func()。只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个sync.Once类型的值 (3).Once类型中还有一个名叫done的uint32类型的字段。它的作用是记录其所属值的Do方法被调用的次数。不过，该字段的值只可能是0或者1。一旦Do方法的首次调用完成，它的值就会从0变为1。 (4).既然done字段的值不是0就是1，那为什么还要使用需要四个字节的uint32类型呢？原因很简单，因为对它的操作必须是“原子”的 123456789101112func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 1 &#123; return &#125; // Slow-path. o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125; ①.Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不够的。因为，如果有两个goroutine都调用了同一个新的Once值的Do方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为false而继续执行Do方法中剩余的代码。 ②.在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。类似单例模式的双重检测机制。它们都会先在临界区之外判断一次关键条件，若条件不满足则立即返回。这通常被称为“快路径”，或者叫做“快速失败路径”。 ③.别看Do方法中的代码不多，但它却应用了一个很经典的编程范式。我们在Go语言及其标准库中，还能看到不少这个经典范式及它衍生版本的应用案例。 (5).Do方法在功能方面的两个特点。 ①.第一个特点，由于Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。 例如，有多个goroutine并发地调用了同一个Once值的Do方法，并且传入的函数都会一直执行而不结束。那么，这些goroutine就都会因调用了这个Do方法而阻塞。因为，除了那个抢先执行了参数函数的goroutine之外，其他的goroutine都会被阻塞在锁定该Once值的互斥锁m的那行代码上。 ②.Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且，这一操作是被挂在defer语句中的。因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1，即使是panic了也是如此。 8.context (1).Context类型：它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。Context类型可以提供一类代表上下文的值。此类值是并发安全的，也就是说它可以被传播给多个goroutine。Context类型的值（以下简称Context值）是可以繁衍的，这意味着我们可以通过一个Context值产生出任意个子值。这些子值可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。 ①.所有的Context值共同构成了一颗代表了上下文全貌的树形结构。 ②.这棵树的树根（或者称上下文根节点）是一个已经在context包中预定义好的Context值，它是全局唯一的。通过调用context.Background函数，我们就可以获取到它。这个上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能。也就是说，它既不可以被撤销（cancel），也不能携带任何数据。 (2).除此之外，context包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。 ①.这些函数的第一个参数的类型都是context.Context，而名称都为parent。顾名思义，这个位置上的参数对应的都是它们将会产生的Context值的父值。 ②.WithCancel函数用于产生一个可撤销的parent的子值。 ③.WithDeadline函数和WithTimeout函数则都可以被用来产生一个会定时撤销的parent的子值。 ④.WithValue函数，我们可以通过调用它，产生一个会携带额外数据的parent的子值 (3).“可撤销的”在context包中代表着什么？“撤销”一个Context值又意味着什么？ ①.Context类型：Done方法会返回一个元素类型为struct{}的接收通道。这个接收通道的用途并不是传递元素值，而是让调用方去感知“撤销”当前Context值的那个信号。 ②.一旦当前的Context值被撤销，这里的接收通道就会被立即关闭。我们都知道，对于一个未包含任何元素值的通道来说，它的关闭会使任何针对它的接收操作立即结束。 123456789101112131415func coordinateWithContext() &#123; total := 12 var num int32 fmt.Printf(&quot;The number: %d [with context.Context]\n&quot;, num) cxt, cancelFunc := context.WithCancel(context.Background()) for i := 1; i &lt;= total; i++ &#123; go addNum(&amp;num, i, func() &#123; if atomic.LoadInt32(&amp;num) == int32(total) &#123; cancelFunc() &#125; &#125;) &#125; &lt;-cxt.Done() fmt.Println(&quot;End.&quot;)&#125; ③.除了让Context值的使用方感知到撤销信号，还能让它们得到“撤销”的具体原因。后者即是Context类型的Err方法的作用。该方法的结果是error类型的，并且其值只可能等于context.Canceled变量的值，或者context.DeadlineExceeded变量的值。前者用于表示手动撤销，而后者则代表：由于我们给定的过期时间已到，而导致的撤销。 ④.对于Context值来说，“撤销”这个词如果当名词讲，指的其实就是被用来表达“撤销”状态的信号；如果当动词讲，指的就是对撤销信号的传达； ⑤.当我们通过调用context.WithCancel函数产生一个可撤销的Context值时，还会获得一个用于触发撤销信号的函数。通过调用这个函数，我们就可以触发针对这个Context值的撤销信号。一旦触发，撤销信号就会立即被传达给这个Context值，并由它的Done方法的结果值（一个接收通道）表达出来。 ⑥.撤销函数只负责触发信号，而对应的可撤销的Context值也只负责传达信号，它们都不会去管后边具体的“撤销”操作。实际上，我们的代码可以在感知到撤销信号之后，进行任意的操作。 ⑦.这里的“撤销”最原始的含义其实就是，终止程序针对某种请求（比如HTTP请求）的响应，或者取消对某种指令（比如SQL指令）的处理。这也是Go语言团队在创建context代码包，和Context类型时的初衷。 (4).撤销信号是如何在上下文树中传播的？ ①.在撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法会返回的那个通道。 ②.然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个Context值会断开它与其父值之间的关联。 ③.我们通过调用context包的WithDeadline函数或者WithTimeout函数生成的Context值也是可撤销的。它们不但可以被手动撤销，还会依据在生成时被给定的过期时间，自动地进行定时撤销。这里定时撤销的功能是借助它们内部的计时器来实现的。 (5).怎样通过Context值携带数据？怎样从中获取数据？ ①.WithValue函数在产生新的Context值（以下简称含数据的Context值）的时候需要三个参数，即：父值、键和值。与“字典对于键的约束”类似，这里键的类型必须是可判等的。 ②.当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种Context值并不是用字典来存储键和值的，后两者只是被简单地存储在前者的相应字段中而已。 ③.Context类型的Value方法就是被用来获取数据的。在我们调用含数据的Context值的Value方法时，它会先判断给定的键，是否与当前值中存储的键相等，如果相等就把该值中存储的值直接返回，否则就到其父值中继续查找。 ④.如果其父值中仍然未存储相等的键，那么该方法就会沿着上下文根节点的方向一路查找下去。注意，除了含数据的Context值以外，其他几种Context值都是无法携带数据的。因此，Context值的Value方法在沿路查找的时候，会直接跨过那几种值。 ⑤.如果我们调用的Value方法的所属值本身就是不含数据的，那么实际调用的就将会是其父辈或祖辈的Value方法。这是由于这几种Context值的实际类型，都属于结构体类型，并且它们都是通过“将其父值嵌入到自身”，来表达父子关系的。 ⑥.Context接口并没有提供改变数据的方法。 9.sync.Pool (1).sync.Pool类型可以被称为临时对象池，它的值可以被用来存储临时的对象。sync.Pool类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了。 ①.临时对象”的意思是：不需要持久使用的某一类值。这类值对于程序来说可有可无，但如果有的话会明显更好。它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。同时，它们也应该是无需被区分的，其中的任何一个值都可以代替另一个。如果你的某类值完全满足上述条件，那么你就可以把它们存储到临时对象池中。 ②.我们可以把临时对象池当作针对某种数据的缓存来用。 ③.sync.Pool类型只有两个方法——Put和Get。接收和返回interface{}类型的数据。 ③.Get方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的New字段创建一个新值，并直接将其返回。 ④.sync.Pool类型的New字段代表着创建临时对象的函数。Get方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结果值并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方。 ⑤.sync.Pool并不是开箱即用的，需要先为Pool指定New字段对应的函数。比如fmt包中123var ppFree = sync.Pool&#123; New: func() interface&#123;&#125; &#123; return new(pp) &#125;,&#125; (2).为什么说临时对象池中的值会被及时地清理掉？ ①.Go语言运行时系统中的垃圾回收器，所以在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。 ②.sync包在被初始化的时候，会向Go语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。一旦池清理函数被注册到了Go语言运行时系统，后者在每次即将执行垃圾回收时就都会执行前者。 ③.在sync包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为*sync.Pool的切片。我们可以称之为池汇总列表。 1234var ( allPoolsMu Mutex allPools []*Pool) ④.通常，在一个临时对象池的Put方法或Get方法第一次被调用的时候，这个池就会被添加到池汇总列表中。正因为如此，池清理函数总是能访问到所有正在被真正使用的临时对象池。更具体地说，池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列表都销毁掉。 ⑤.最后，池清理函数会把池汇总列表重置为空的切片。如此一来，这些池中存储的临时对象就全部被清除干净了。 (3).临时对象池存储值所用的数据结构是怎样的？ ①.在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值。这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同。P存在的一个很重要的原因是为了分散并发程序的执行压力，而让临时对象池中的本地池列表的长度与P的数量相同的主要原因也是分散压力。这里所说的压力包括了存储和性能两个方面。 ②.在本地池列表中的每个本地池都包含了三个字段：存储私有临时对象的字段private、代表了共享临时对象列表的字段shared，以及一个sync.Mutex类型的嵌入字段。 12345type poolLocalInternal struct &#123; private interface&#123;&#125; // Can be used only by the respective P. shared []interface&#123;&#125; // Can be used by any P. Mutex // Protects shared.&#125; ③.实际上，每个本地池都对应着一个P。我们都知道，一个goroutine要想真正运行就必须先与某个P产生关联。也就是说，一个正在运行的goroutine必然会关联着某个P。 ④.在程序调用临时对象池的Put方法或Get方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的goroutine关联的那个P的ID。换句话说，一个临时对象池的Put方法或Get方法会获取到哪一个本地池，完全取决于调用它的代码所在的goroutine关联的那个P。 (4).临时对象池是怎样利用内部数据结构来存取值的？ ①.临时对象池的Put方法总会先试图把新的临时对象，存储到对应的本地池的private字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。只有当这个private字段已经存有某个值时，该方法才会去访问本地池的shared字段。 ②.相应的，临时对象池的Get方法，总会先试图从对应的本地池的private字段处获取一个临时对象。只有当这个private字段的值为nil时，它才会去访问本地池的shared字段。 ③.一个本地池的shared字段原则上可以被任何goroutine中的代码访问到，不论这个goroutine关联的是哪一个P。这也是我把它叫做共享临时对象列表的原因。相比之下，一个本地池的private字段，只可能被与之对应的那个P所关联的goroutine中的代码访问到，所以可以说，它是P级私有的。 10.并发安全字典sync.Map (1).这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全。同时，它的存、取、删等操作都可以基本保证在常数时间内执行完毕。换句话说，它们的算法复杂度与map类型一样都是O(1)的。 ①.与单纯使用原生map和互斥锁的方案相比，使用sync.Map可以显著地减少锁的争用。sync.Map本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。 ②.无论在何种场景下使用sync.Map，我们都需要注意，与原生map明显不同，它只是Go语言标准库中的一员，而不是语言层面的东西。也正因为这一点，Go语言的编译器并不会对它的键和值进行特殊的类型检查。 (2).并发安全字典对键的类型有要求吗？键的实际类型不能是函数类型、字典类型和切片类型。可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值（即：reflect.Type类型的值），然后再调用这个值的Comparable方法，得到确切的判断结果。 123if !reflect.TypeOf(key).Comparable() &#123; panic(&quot;key is not comparable&quot;)&#125; (3).怎样保证并发安全字典中的键和值的类型正确性？ 使用反射进行判断，但是反射浪费性能123456789101112type ConcurrentMap struct &#123;m sync.MapkeyType reflect.TypevalueType reflect.Type&#125;func (cMap *ConcurrentMap) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;if reflect.TypeOf(key) != cMap.keyType &#123; return&#125;return cMap.m.Load(key)&#125; (4).并发安全字典如何做到尽量避免使用锁 ①.sync.Map类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的map作为存储介质:read和 dirty 123456789type Map struct &#123; mu Mutex read atomic.Value // readOnly dirty map[interface&#123;&#125;]*entry misses int&#125; ②.read字段是sync/atomic.Value类型的。可看作一个快照，它总会在条件满足时，去重新保存所属的sync.Map值中包含的所有键值对。它的只读特性只是对于其中键的集合而言的，它虽然不会增减其中的键，但却允许变更其中的键所对应的值. sync.Map在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上封装了一层。它先把值转换为了unsafe.Pointer类型的值，然后再把后者封装，并储存在其中的原生字典中。如此一来，在变更某个键所对应的值的时候，就也可以使用原子操作了。 ③.dirty：它存储键值对的方式与read字段中的原生字典一致。脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。 sync.Map在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定“只读字典中没有，但脏字典中可能会有这个键”的时候，它才会在锁的保护下去访问脏字典。 ④.sync.Map在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。否则，它才会在锁的保护下把键值对存储到脏字典中。 ⑤.顺便说一句，只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。 ⑥.这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻辑删除的键值对永远会被无视。 ⑦.对于删除键值对，sync.Map会先去检查只读字典中是否有对应的键。如果没有，脏字典中可能有，那么它就会在锁的保护下，试图从脏字典中删掉该键值对。 ⑧.最后，sync.Map会把该键值对中指向值的那个指针置为nil，这是另一种逻辑删除的方式。 ⑨.只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read字段中，然后把代表脏字典的dirty字段的值置为nil。在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。理所当然，这些转换操作肯定都需要在锁的保护下进行。 (5).sync.Map的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同。 ①.由于只读字典中键的集合不能被改变，所以其中的键值对有时候可能是不全的。相反，脏字典中的键值对集合总是完全的，并且其中不会包含已被逻辑删除的键值对。 ②.在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。 ③.在写操作中，新增键值对影响 &gt; 删除操作 &gt; 修改操作]]></content>
      <categories>
        <category>01.Golang</category>
        <category>10.go的同步工具</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.go的数据类型]]></title>
    <url>%2F2019%2F08%2F11%2F9.go%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.函数是一等的公民 (1).在Go语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型，可以把函数作为一个普通的值赋给一个变量。 ①.简单来说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身为普通的值，在其他函数间传递、赋予变量、做类型判断和转换等等，就像切片和字典的值那样。 ②.而更深层次的含义就是：函数值可以由此成为能够被随意传播的独立逻辑组件（或者说功能模块）。 ③.对于函数类型来说，它是一种对一组输入、输出进行模板化的重要工具，它比接口类型更加轻巧、灵活，它的值也借此变成了可被热替换的逻辑组件。 1234567891011package mainimport &quot;fmt&quot;type Printer func(contents string) (n int, err error)func printToStd(contents string) (bytesNum int, err error) &#123; return fmt.Println(contents)&#125;func main() &#123; var p Printer p = printToStd p(&quot;something&quot;)&#125; ④.只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可以说它们是一样的函数，或者说是实现了同一个函数类型的函数。 (2).怎样编写高阶函数？ ①.什么是高阶函数？只要满足了下面其中任意一个特点，我们就可以说这个函数是一个高阶函数。高阶函数也是函数式编程中的重要概念和特征。具体的问题是，我想通过编写calculate函数来实现两个整数间的加减乘除运算，但是希望两个整数和具体的操作都由该函数的调用方给出，那么，这样一个函数应该怎样编写呢。 接受其他的函数作为参数传入； 把其他的函数作为结果返回。 ②.首先声明一个名叫operate的函数类型，它有两个参数和一个结果，都是int类型的。 type operate func(x, y int) int ③.其次编写calculate函数的签名部分。这个函数除了需要两个int类型的参数之外，还应该有一个operate类型的参数。 123456func calculate(x int, y int, op operate) (int, error) &#123; if op == nil &#123; return 0, errors.New(&quot;invalid operation&quot;) &#125; return op(x, y), nil&#125; ④.把函数当成一个值进行传递 123op := func(x, y int) int &#123; return x + y&#125; ⑤.把其他函数作为结果返回 123456789101112131415161718type operate func(x, y int) inttype calculateFunc func(x int, y int) (int, error)func genCalculator(op operate) calculateFunc &#123; return func(x, y int) (int, error) &#123; if op == nil &#123; return 0, errors.New(&quot;invalid operate&quot;) &#125; return op(x, y), nil &#125;&#125;···x, y := 56, 78op := func(x, y int) int &#123; return x + y&#125;add := genCalculator(op)result, _ := add(x, y)··· (3).如何实现闭包？ ①.自由变量：是一个变量。它在闭包函数中，既不代表当前函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的。闭包函数就是因为引用了自由变量，而呈现出了一种“不确定”的状态，也叫“开放”状态。 ②.闭包函数，它的内部逻辑并不是完整的，有一部分逻辑需要这个自由变量参与完成，而后者到底代表了什么在闭包函数被定义的时候却是未知的。 12345678func genCalculator(op operate) calculateFunc &#123; return func(x, y int) (int, error) &#123; if op == nil &#123; return 0, errors.New(&quot;invalid operate&quot;) &#125; return op(x, y), nil &#125;&#125; ③.genCalculator返回的匿名的函数就是一个闭包函数。它里面使用的变量op既不代表它的任何参数或结果也不是它自己声明的，而是定义它的genCalculator函数的参数，所以是一个自由变量。 这个自由变量究竟代表了什么，这一点并不是在定义这个闭包函数的时候确定的，而是在genCalculator函数被调用的时候确定的。 只有给定了该函数的参数op，我们才能知道它返回给我们的闭包函数可以用于什么运算。 当程序运行到这里的时候，op就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转到了“闭合”状态，至此也就真正地形成了一个闭包。 (4).闭包的意义 ①.实现闭包的意义又在哪里呢？表面上看，**我们只是延迟实现了一部分程序逻辑或功能而已，但实际上，我们是在动态地生成那部分程序逻辑。 ②.我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序行为。这与GoF设计模式中的“模板方法”模式有着异曲同工之妙。 2.结构体 (1).结构体类型基础知识 ①.结构体类型也可以不包含任何字段，这样并不是没有意义的，因为我们还可以为类型关联上一些方法，这里你可以把方法看做是函数的特殊版本。 ②.函数是独立的程序实体。我们可以声明有名字的函数，也可以声明没名字的函数，还可以把它们当做普通的值传来传去。我们能把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出（或者说一类逻辑组件）的代表。 ③.方法却不同，它需要有名字，不能被当作值来看待，最重要的是，它必须隶属于某一个类型。方法所属的类型会通过其声明中的接收者（receiver）声明体现出来。 接收者的类型其实就是当前方法所属的类型，而接收者的名称，则用于在当前方法中引用它所属的类型的当前值。123456789101112131415// AnimalCategory 代表动物分类学中的基本分类法。type AnimalCategory struct &#123; kingdom string // 界。 phylum string // 门。 class string // 纲。 order string // 目。 family string // 科。 genus string // 属。 species string // 种。&#125;func (ac AnimalCategory) String() string &#123; return fmt.Sprintf(&quot;%s%s%s%s%s%s%s&quot;, ac.kingdom, ac.phylum, ac.class, ac.order, ac.family, ac.genus, ac.species)&#125; ④.方法隶属的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。 一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现重名。并且，如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复。 我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作是附加在其中数据之上的一个能力或者一项操作。将属性及其能力（或者说数据及其操作）封装在一起，是面向对象编程（object-oriented programming）的一个主要原则。 (2). 嵌入字段 ①.如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么？ 1234type Animal struct &#123; scientificName string // 学名。 AnimalCategory // 动物基本分类。&#125; Go语言规范规定，如果一个字段的声明中只有字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被称为匿名字段。我们可以通过此类型变量的名称后跟“.”，再后跟嵌入字段类型的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。123func (a Animal) Category() string &#123; return a.AnimalCategory.String()&#125; ②.只要名称相同，无论这两个方法的签名(参数或返回值)是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。 上面的Animal类型的String的方法会替换掉AnimalCategory的String方法 ③.字段名称也是类似的，也会存在“屏蔽”的现象，就像Java中子类覆盖父类，局部变量覆盖全局变量。即使在两个同名的成员一个是字段，另一个是方法的情况下，这种“屏蔽”现象依然会存在。 ④.不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择到嵌入字段的字段或方法 ⑤.多层嵌入的问题：“屏蔽”现象会以嵌入的层级为依据，嵌入层级越深的字段或方法越可能被“屏蔽”。例如：如果Animal类型嵌入到Cat类型中，只有当Cat类型和Animal类型都没有String方法的时候，AnimalCategory的String方法菜会被调用。 ⑥.最后的最后，如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个编译错误，因为编译器无法确定被选择的成员到底是哪一个。 (3).Go语言是用嵌入字段实现了继承吗？ ①.Go语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合。 ②.面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而且这种可扩展性是通过侵入的方式来实现的。 ③.类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。我们要做的只是把类型当做字段嵌入进来，然后坐享其成地使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们还可以用“包装”或“屏蔽”的方式去调整和优化。 ④.“Go语言用嵌入字段实现了继承”的说法是错的，go语言中没有继承，只有组合 (4).值方法和指针方法都是什么意思，有什么区别？ ①.值方法：方法的接收者类型必须是某个自定义的数据类型，而且不能是接口类型或接口的指针类型。所谓的值方法，就是接收者类型是非指针的自定义数据类型的方法。 ②.指针方法：所谓的指针方法，就是接收者类型是指针类型的方法。123func (cat *Cat) SetName(name string) &#123; cat.name = name&#125; (5).那么值方法和指针方法之间有什么不同点呢？它们的不同如下所示。 ①.第一点： 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。 而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。 ②.一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。 严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go语言会适时地为我们进行自动地转译，使得我们在这样的值上也能调用到它的指针方法。 比如，在Cat类型的变量cat之上，之所以我们可以通过cat.SetName(“monster”)修改猫的名字，是因为Go语言把它自动转译为了(&amp;cat).SetName(“monster”)，即：先取cat的指针值，然后在该指针值上调用SetName方法。 ③.一个类型的方法集合中有哪些方法与它能实现哪些接口类型是息息相关的。如果一个基本类型和它的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量就也会有差异，除非这两个数量都是零。 比如，一个指针类型实现了某某接口类型，但它的基本类型却不一定能够作为该接口的实现类型。 3.接口 (1).正确使用接口的基础知识 ①.接口类型与其他数据类型不同，它是没法被实例化的。 ②.接口类型的类型字面量与结构体类型的看起来有些相似，它们都用花括号包裹一些核心信息。只不过，结构体类型包裹的是它的字段声明，而接口类型包裹的是它的方法定义。 ③.接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。 ④.对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。这是一种无侵入式的接口实现方式。 (2).怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？ ①.主要是两个充分必要条件，一个是“两个方法的签名需要完全一致”，另一个是“两个方法的名称要一模一样” ②.指针类型方法集合 = 值类型方法集合 + 接收类型为引用类型的方法。 ③.Dog类型本身的方法集合中只包含了2个方法，也就是所有的值方法。而它的指针类型*Dog方法集合却包含了3个方法。所以*Dog类型就成为了Pet接口的实现类型。 1234567891011121314151617type Pet interface &#123; SetName(name string) Name() string Category() string&#125;type Dog struct &#123; name string // 名字。&#125;func (dog *Dog) SetName(name string) &#123; dog.name = name&#125;func (dog Dog) Name() string &#123; return dog.name&#125;func (dog Dog) Category() string &#123; return &quot;dog&quot;&#125; ④.可以声明并初始化一个Dog类型的变量dog，然后把它的指针值赋给类型为Pet的变量pet。 12dog := Dog&#123;&quot;little pig&quot;&#125;var pet Pet = &amp;dog ⑤.这里有几个名词需要你先记住。对于一个接口类型的变量来说，例如上面的变量pet，我们赋给它的值可以被叫做它的实际值（也称动态值），而该值的类型可以被叫做这个变量的实际类型（也称动态类型）。 动态类型这个叫法是相对于静态类型而言的。对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet，但是它的动态类型却会随着我们赋给它的动态值而变化。 (3).当我们为一个接口变量赋值时会发生什么？ ①.因为struct是值类型，所以在赋值时会发生拷贝。上面的例子中，去除SetName，是Dog成为接口的实现类型，在以上代码执行后，pet变量的字段name的值会是什么？答：首先，由于dog的SetName方法是指针方法，所以dog的name字段的值就一定是”monster”。为什么dog的name字段值变了，而pet的却没有呢？因为pet的接口变量(注意是接口变量)声明并赋值后，发生了值拷贝，底层是怎么实现的？。 123dog := Dog&#123;&quot;little pig&quot;&#125;var pet Pet = dogdog.SetName(&quot;monster&quot;) ②.当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。 这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量的那个实际的值。这时pet的专用数据结构中的值中包含了dog值的副本。 姑且把这个专用的数据结构叫做iface吧，在Go语言的runtime包中它其实就叫这个名字。 iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等 总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值 ③.例子 ，此处的pet不是nil，Go语言会识别出赋予pet的值是一个*Dog类型的nil。然后，Go语言就会用一个iface的实例包装它，包装后的产物肯定就不是nil了。 123var dog1 *Dogdog2 := dog1var pet Pet = dog2 (4).怎样实现接口之间的组合？ ①.接口类型间的嵌入也被称为接口的组合。接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。 ②.与结构体类型间的嵌入很相似，我们只要把一个接口类型的名称直接写到另一个接口类型的成员列表中就可以了。比如： 123456789type Animal interface &#123; ScientificName() string Category() string&#125;type Pet interface &#123; Animal Name() string&#125; ③.Go语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。— 单一职责原则 Go语言标准库代码包io中的ReadWriteCloser接口和ReadWriter接口就是这样的例子，它们都是由若干个小接口组合而成的。以io.ReadWriteCloser接口为例，它是由io.Reader、io.Writer和io.Closer这三个接口组成的。 这三个接口都只包含了一个方法，是典型的小接口。它们中的每一个都只代表了一种能力，分别是读出、写入和关闭。我们编写这几个小接口的实现类型通常都会很容易。并且，一旦我们同时实现了它们，就等于实现了它们的组合接口io.ReadWriteCloser。 即使我们只实现了io.Reader和io.Writer，那么也等同于实现了io.ReadWriter接口，因为后者就是前两个接口组成的。可以看到，这几个io包中的接口共同组成了一个接口矩阵。它们既相互关联又独立存在 4.关于指针的有限操作 (1).指针 ①.指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的起始地址，比如，某个变量、某个字段或某个函数。 (2).Go语言中的哪些值是不可寻址的？ 常量的值、基本类型值的字面量、算术操作的结果值、对各种字面量的索引表达式和切片表达式的结果值(不过有一个例外，对切片字面量的索引结果值却是可寻址的)、对字符串变量的索引表达式和切片表达式的结果值、对字典变量的索引表达式的结果值、函数字面量和方法字面量以及对它们的调用表达式的结果值、结构体字面量的字段值(也就是对结构体字面量的选择表达式的结果值)、类型转换表达式的结果值、类型断言表达式的结果值、接收表达式的结果值。有如下规律 ①.不可变的值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此。常量的值总是会被存储到一个确切的内存区域中，基于它的索引或切片的结果值也都是不可寻址的，因为即使拿到了这种值的内存地址也改变不了什么。 ②.绝大多数被视为临时结果的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果值也属于临时结果。但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。 值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是“临时的”。 ③.若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。 ④.最重要的：如果我们把临时结果赋给一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。 (3).不可寻址的值在使用上有哪些限制？记住三个规则 ①.在go中，只要在++或–的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的。不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。 ②.在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。map[1] = 5 ③.在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。 (4).怎样通过unsafe.Pointer操纵可寻址的值？ ①.unsafe.Pointer可以表示任何指向可寻址的值的指针，同时它也是前面提到的指针值和uintptr值之间的桥梁。unsafe.Pointer是像*Dog类型的值这样的指针值和uintptr值之间的桥梁，那么我们怎样利用unsafe.Pointer的中转和uintptr的底层操作来操纵像dog这样的值呢？ 这是一项黑科技。它可以绕过Go语言的编译器和其他工具的重重检查，并达到潜入内存修改数据的目的。这并不是一种正常的编程手段，使用它会很危险，很有可能造成安全隐患。 我们总是应该优先使用常规代码包中提供的API去编写程序，当然也可以把像reflect以及go/ast这样的代码包作为备选项。作为上层应用的开发者，请谨慎地使用unsafe包中的任何程序实体。 ②.例子 123dog := Dog&#123;&quot;little pig&quot;&#125;dogP := &amp;dogdogPtr := uintptr(unsafe.Pointer(dogP)) 这背后隐藏着一些转换规则，如下： 一个指针值（比如*Dog类型的值）可以被转换为一个unsafe.Pointer类型的值，反之亦然。 一个uintptr类型的值也可以被转换为一个unsafe.Pointer类型的值，反之亦然。 一个指针值无法被直接转换成一个uintptr类型的值，反过来也是如此。 所以，对于指针值和uintptr类型值之间的转换，必须使用unsafe.Pointer类型的值作为中转。那么，我们把指针值转换成uintptr类型的值有什么意义吗？ 12namePtr := dogPtr + unsafe.Offsetof(dogP.name)nameP := (*string)(unsafe.Pointer(namePtr)) 只有uintptr才能进行指针操作]]></content>
      <categories>
        <category>01.Golang</category>
        <category>09.go的数据类型</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.基础]]></title>
    <url>%2F2019%2F08%2F11%2F8.%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一.基础语法 1.引用包不使用，在main方法执行之前使用 1234567package mainimport( _ “add”)func main () &#123; fmt.Println(“add not refer:”)&#125; 2.函数声明： func 函数名字 (参数列表) (返回值列表）{} 3.go语言是编译语言，所以不能在全局区域写执行语句(解释语言及脚本语言的特性)，需要将把它移动到方法内部 4.值类型和引用类型 (1).值类型：变量直接存储值，内存通常在栈中分配。基本数据类型int、float、bool、string以及数组和struct。 例子：变量 a –&gt; 存储实际值 (2).引用类型：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配。通过GC回收 。指针、slice、map、chan等都是引用类型。 例子：变量 b –&gt; 指向模块内存地址0xabaef –&gt; 内存地址上存储实际值 5.函数 (1).函数参数传递方式分值传递和引用传递 (2).可以命名返回值的名字 (3).map、slice、chan、指针、interface默认以引用的方式传递 (4).无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低 6.defer用途： (1).当函数返回时，执行defer语句。因此，可以用来做资源清理 关闭文件句柄 12345func read() &#123; file := open(filename) defer file.Close() //文件操作&#125; 锁资源释放 12345func read() &#123; mc.Lock() defer mc.Unlock() //其他操作&#125; 数据库连接释放 123456789func read() &#123; conn ,err := openDatabase() //先处理异常，然后defer处理资源 if err != nil &#123; return &#125; defer conn.Close() //其他操作&#125; (2).多个defer语句，按先进后出的方式执行 (3).defer语句中的变量，在defer声明时就决定了。 (4).defer可以执行语句，所以可以执行匿名 123defer func()&#123; //处理逻辑&#125;() 6.时间格式化 1234now := time.Now()fmt.Println(now.Format(“02/1/2006 15:05”))fmt.Println(now.Format(“2006/1/02 15:05”))fmt.Println(now.Format(“2006/1/02”)) 7.内置函数 (1).close：主要用来关闭channel (2).len：用来求长度，比如string、array、slice、map、channel (3).new：用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针 (4).make：用来分配内存，主要用来分配引用类型，比如chan、map、slice (5).append：用来追加元素到数组、slice中 (6).panic和recover：用来做错误处理 (7).copy(target，source)：拷贝target不会扩容 (8).delete(map,key):删除key 8.反射 (1).两个函数 reflect.TypeOf(变量)，获取变量的类型，返回reflect.Type类型 reflect.ValueOf(变量):获取变量的值，返回reflect.Value类型,关键用法,转成value类型之后，value提供了很多方法，可以做很多东西 reflect.Value.Kind，获取变量的类别，返回一个常量 reflect.Value.Interface()，转换成interface{}类型. 变量&lt;—-&gt;Interface{}&lt;—-&gt;Reflect.Value(调用它的Interface()方法) (2).reflect.Value中的方法 kind：推断变量的类别，而不是类型，比如struct，注意它对应refect.Struct常量 reflect.Type：返回的是类型，比如student、teacher等结构体 (3).如果想改变变量的值，reflect.ValueOf(变量)方法传入的变量必须是指针，转成value之后，通过value.Elem()，获取指针对应的值，类似*P操作。 v := reflect.ValueOf(x):v是x的一个拷贝，修改v，x不会修改;还是值类型和引用类型的原因 fv.Elem()用来获取指针指向的变量，相当于： var a *int; *a = 100 (4).反射操作结构体 reflect.Value.NumField()/NumMethod()获取结构体中字段、方法的个数 reflect.Value.Method(n).Call来调用结构体中的方法 reflect.Value.Fileld[i]]]></content>
      <categories>
        <category>01.Golang</category>
        <category>08.基础</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.go的集合工具]]></title>
    <url>%2F2019%2F08%2F11%2F7.go%E7%9A%84%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.数组（array）类型和切片（slice）类型 (1).比较： 它们的共同点是都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。 不过，它们最重要的不同是：数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。 数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，[1]string和[2]string就是两个不同的数组类型。 而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。 (2).我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。 ①.Go语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。 ②.Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。 ③.如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。 (3).怎样正确估算切片的长度和容量？ ①.切片的容量实际上代表了它的底层数组的长度 ②.切片可以想象成一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素 ③.切片代表的窗口也会被划分成一个一个的小格子，就像我们家里的窗户那样。每个小格子都对应着其底层数组中的某一个元素。这个窗口最左边的那个小格子对应的正好是其底层数组中的第一个元素，即索引为0的那个元素 ④.当我们用make函数或切片值字面量（比如[]int{1, 2, 3}）初始化一个切片时，该窗口最左边的那个小格子总是会对应其底层数组中的第1个元素。 12s3 := []int&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;s4 := s3[3:6] ⑤.容量：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数，在底层数组不变的情况下，切片代表的窗口可以向右扩展，直至其底层数组的末尾。注意，切片代表的窗口是无法向左扩展的。也就是说，我们永远无法透过s4看到s3中最左边的那3个元素。 (4).怎样估算切片容量的增长 一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的2倍。 (5).切片的底层数组什么时候会被替换？ 确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候Go语言一定会生成新的底层数组，但是它也同时生成了新的切片。它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。 在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。 2.container包中的那些容器(链表实现) (1).List和Element，List实现了一个双向链表（以下简称链表），而Element则代表了链表中元素的结构。 (2).可以把自己生成的Element类型值传给链表吗？ ①.把Element加入到list中的方法 1234func (l *List) MoveBefore(e, mark *Element)func (l *List) MoveAfter(e, mark *Element)func (l *List) MoveToFront(e *Element)func (l *List) MoveToBack(e *Element) ②.如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？典型回答：不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的Element值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的Element值插入其中。 ③.在List包含的方法中，用于插入新元素的那些方法都只接受interface{}类型的值。这些方法在内部会使用Element值，包装接收到的新元素。 ④.这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。 ⑤.API Front和Back方法分别用于获取链表中最前端和最后端的元素， InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素， PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。 这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。 (3).为什么链表可以做到开箱即用？ ①.List和Element都是结构体类型，结构体类型声明变量后，系统会指定默认值 比如，经过语句var a [2]int声明的变量a的值，将会是一个包含了两个0的整数数组。又比如，经过语句var s []int声明的变量s的值将会是一个[]int类型的、值为nil的切片。 var l list.List声明的变量，默认值是是一个长度为0的链表。 ②.声明为var l list.List之后的变量，开箱即用，可以直接拿来使用！！！不需要进行初始化 Go语言标准库中很多结构体类型的程序实体都做到了开箱即用。 ③.原因在于“延迟初始化”机制 所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。 例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的CPU和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。 如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。 ④.在这里的链表实现中，一些方法是无需对是否初始化做判断的。 比如Front方法和Back方法，一旦发现链表的长度为0,直接返回nil就好了。 又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。 ⑤.链表的PushFront方法、PushBack方法、PushBackList方法以及PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。 我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。 (4).Ring与List的区别在哪儿？ ①.container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。List的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。 ②.既然Ring和List在本质上都是循环链表，那它们到底有什么不同呢？ Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。 在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。 仅通过var r ring.Ring语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。 Ring值的Len方法的算法复杂度是O(N)的，而List值的Len方法的算法复杂度则是O(1)的。这是两者在性能方面最显而易见的差别。 (5).切片与数组的比较 切片本身有着占用内存少和创建便捷等特点，但它的本质上还是数组。切片的一大好处是可以让我们通过窗口快速地定位并获取，或者修改底层数组中的元素。 不过，当我们想删除切片中的元素的时候就没那么简单了。元素复制一般是免不了的，就算只删除一个元素，有时也会造成大量元素的移动。这时还要注意空出的元素槽位的“清空”，否则很可能会造成内存泄漏。 另一方面，在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配的量以及元素复制的次数可能就很可观了，这肯定会对程序的性能产生负面的影响。 尤其是当我们没有一个合理、有效的”缩容“策略的时候，旧的底层数组无法被回收，新的底层数组中也会有大量无用的元素槽位。过度的内存浪费不但会降低程序的性能，还可能会使内存溢出并导致程序崩溃。 3.GO中的map (1).为什么字典的键类型会受到约束? ①.slice和lis都是单一元素的容器。字典（map）存储键值对 ②.Go语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。 ③.键的类型为什么受限，原因在于，哈希表中最重要的一个过程：映射。 123456789101112aMap := map[string]int&#123; &quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3,&#125;k := &quot;two&quot;v, ok := aMap[k]if ok &#123; fmt.Printf(&quot;The element of key %q: %d\n&quot;, k, v)&#125; else &#123; fmt.Println(&quot;Not found!&quot;)&#125; 哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键-元素对。映射过程的第一步就是：把键值转换为哈希值。在Go语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。 (2).字典的键类型不能是哪些类型？ ①.典型回答是：Go语言字典的键类型不可以是函数类型、字典类型和切片类型。Go语言规范规定，在键类型的值之间必须可以施加操作符==和!=。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。 ②.为什么键类型的值必须支持判等操作？“哈希碰撞”时候，需要进行持判 (3).应该优先考虑哪些类型作为字典的键类型? ①.那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？只从性能的角度看。“把键值转换为哈希值”以及“把要查找的键值与哈希桶中的键值做对比”， 明显是两个重要且比较耗时的操作。 ②.求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。 ③.对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go语言都有一套算法与之对应。这套算法中就包含了哈希和判等。 ④.基本类型： 宽度越小的类型速度通常越快：对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此 长度越短求哈希越快：对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度。 ⑤.高级类型 对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上 对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定。 ⑥.选择策略：优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。 (4).在值为nil的字典上执行读操作会成功吗，那写操作呢? 除了添加键-元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键-元素对的时候，Go语言的运行时系统就会立即抛出一个panic。 4.通道的基础知识 (1).通道：ch1 := make(chan int, 5) ①.通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。 ②.当容量为0时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于0时，我们可以称为缓冲通道，也就是带有缓冲的通道。非缓冲通道和缓冲通道有着不同的数据传递方式 ③.一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符&lt;-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。 (2).对通道的发送和接收操作都有哪些基本的特性？它们的基本特性如下。 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。 发送操作和接收操作中对元素值的处理都是不可分割的。 发送操作在完全完成之前会被阻塞。接收操作也是如此。 (3).第一个基本特性。 ①.在同一时刻，Go语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。 ②.类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。 ③.这里所谓的并发执行是指：多个代码块分别在不同的goroutine之中，并有机会在同一个时间段内被执行。 ④.对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。 ⑤.这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。 (4).第二个基本特性 ①.这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。 例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。 又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。 ②.这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。 (5).第三个基本特性。 ①.一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。 ②.更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的goroutine，以使它去争取继续运行代码的机会。 ③.另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。 ④.在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的goroutine收到了运行时系统的通知并重新获得运行机会为止。 (5).发送操作和接收操作在什么时候可能被长时间的阻塞？ ①.缓冲通道（元素个数 &gt; 0）: 如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。这时，通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。 如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的goroutine，并使它再次执行接收操作。 因此而等待的、所有接收操作所在的goroutine，都会按照先后顺序被放入通道内部的接收等待队列。 ②.非缓冲通道 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。 并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。 ③.对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的goroutine中的任何代码，都不再会被执行。 当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。我们一定不要忘记初始化通道！ (6).发送操作和接收操作在什么时候会引发panic？ ①.对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发panic。但是通道一旦关闭，再对它进行发送操作，就会引发panic。另外，如果我们试图关闭一个已经关闭了的通道，也会引发panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。 ②.更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。 ③.因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。 5.单向通道 (1).单向通道 定义： var uselessChan = make(chan&lt;- int, 1)：chan&lt;- 只能发而不能收 var uselessChan = make(&lt;-chan int, 1)：&lt;-chan 只能收不能发 (2).通道就是为了传递数据而存在的，声明一个只有一端（发送端或者接收端）能用的通道没有任何意义。那么，单向通道的用途究竟在哪儿呢？ ①.func关键字声明了一个叫做SendInt的函数。这个函数只接受一个chan&lt;- int类型的参数。在这个函数中的代码只能向参数ch发送元素值，而不能从它那里接收元素值。这就起到了约束函数行为的作用。 123func SendInt(ch chan&lt;- int) &#123; ch &lt;- rand.Intn(1000)&#125; ②.在实际场景中，这种约束一般会出现在接口类型声明中的某个方法定义上。 123 type Notifier interface &#123;SendInt(ch chan&lt;- int) &#125; 接口中的方法定义与函数声明很类似，但是只包含了方法名称、参数列表和结果列表。 一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现做出约束。 在这里，Notifier接口中的SendInt方法只会接受一个发送通道作为参数，所以，在该接口的所有实现类型中的SendInt方法都会受到限制。这种约束方式还是很有用的，尤其是在我们编写模板代码或者可扩展的程序库的时候。 我们在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没必要用发送通道，因为Go语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。intChan1 := make(chan int, 3);SendInt(intChan1) ③.我们还可以在函数声明的结果列表中使用单向通道 123456789101112131415161718191.定义func getIntChan() &lt;-chan int &#123; num := 5 ch := make(chan int, num) for i := 0; i &lt; num; i++ &#123; ch &lt;- i &#125; //发送方关闭通道，暴露给外部后，只能收不能发 close(ch) return ch&#125;2.使用intChan2 := getIntChan()for elem := range intChan2 &#123; fmt.Printf(&quot;The element in intChan2: %v\n&quot;, elem)&#125;一、这样一条for语句会不断地尝试从intChan2种取出元素值，即使intChan2被关闭，它也会在取出所有剩余的元素值之后再结束执行。二、当intChan2中没有元素值时，它会被阻塞在有for关键字的那一行，直到有新的元素值可取。三、假设intChan2的值为nil，那么它会被永远阻塞在有for关键字的那一行。 (3).select语句与通道怎样联用？ ①.select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。 ②.select语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。 ③.由于select语句是专为通道而设计的，所以每个case表达式中都只能包含操作通道的表达式，比如接收表达式。12345678910111213141516intChannels := [3]chan int&#123; make(chan int, 1), make(chan int, 1), make(chan int, 1),&#125;// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。select &#123;case &lt;-intChannels[0]: fmt.Println(&quot;The first candidate case is selected.&quot;)case &lt;-intChannels[1]: fmt.Println(&quot;The first candidate case is selected.&quot;)case elem := &lt;-intChannels[2]: fmt.Printf(&quot;The third candidate case is selected, the element is %d.\n&quot;, elem)default: fmt.Println(&quot;No candidate case is selected!&quot;)&#125; (4).在使用select语句的时候，我们首先需要注意下面几个事情 ①.如果像上述示例那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。 ②.如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞。直到至少有一个case表达式满足条件为止。 ③.我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。 12345678910111213intChan := make(chan int, 1)// 一秒后关闭通道。time.AfterFunc(time.Second, func() &#123; close(intChan)&#125;)select &#123;case _, ok := &lt;-intChan: if !ok &#123; fmt.Println(&quot;The candidate case is closed.&quot;) break &#125; fmt.Println(&quot;The candidate case is selected.&quot;)&#125; ④.select语句只能对其中的每一个case表达式各求值一次。所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在for语句中嵌入select语句的方式实现。 (5).select语句的分支选择规则都有哪些 ？ ①.对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。 ②.select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推 ③.对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。 ④.仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的goroutine）就会被唤醒，这个候选分支就会被执行。 ⑤.如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使select语句是在被唤醒时发现的这种情况，也会这样做。 ⑥.一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。 ⑦.select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>07.go的集合工具</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.变量作用域]]></title>
    <url>%2F2019%2F08%2F11%2F6.%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 库源码文件 (1).代码包声明的基本规则 ①.第一条规则，同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。 代码包指的是：文件开头package 关键字后面的代码包声明 如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。 ②.第二条规则，源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。 对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同。也可以通过go build -o 指定名称 (2).大白话：import的时候，根据相对路径引入目标目录下的文件；方法调用的时候，使用代码包声明进行调用。1234567891011package 代码包声明import ( .... //github.com...指的是相对路径，表示引入相对路径下(相对于GOPATH)的文件 &quot;github.com/keegancsmith/rpc&quot; ...)//假如github.com/keegancsmith/rpc下的文件代码包声明为 rpc//方法调用，必须是大写开头rpc.Xxxx 2.Go语言中的程序实体 (1).包括变量、常量、函数、结构体和接口 (2).除了var name string之外，声明变量还有几种方式？需要知道两点：一个是Go语言中的类型推断，以及它在代码中的基本体现，另一个是短变量声明的用法。 ①.第一种方式：var name = *flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;) 类型*string代表的是字符串的指针类型，而不是字符串类型。代码在声明变量name的同时，还为它赋了值，而这时声明中并没有显式指定name的类型。 ②.第二种方式：name := *flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)。实际上就是Go语言的类型推断再加上一点点语法糖。我们只能在函数体内部使用短变量声明。在编写if、for或switch语句的时候，我们经常把它安插在初始化子句中，并用来声明一些临时的变量。而相比之下，第一种方式更加通用，它可以被用在任何地方。 ③.类型推断是一种编程语言在编译期自动解释表达式类型的能力(表达式类型就是对表达式进行求值后得到结果的类型)。 ④.Go语言的类型推断可以带来哪些好处？体现在我们写代码之后的那些事情上，比如代码重构。 12345678910111213package mainimport ( &quot;flag&quot; &quot;fmt&quot;)func main() &#123; var name = getTheFlag() flag.Parse() fmt.Printf(&quot;Hello, %v!\n&quot;, *name)&#125;func getTheFlag() *string &#123; return flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)&#125; 我们可以用getTheFlag函数包裹（或者说包装）那个对flag.String函数的调用，并把其结果直接作为getTheFlag函数的结果，结果的类型是*string。这样一来，var name =右边的表达式，可以变为针对getTheFlag函数的调用表达式了。这实际上是对“声明并赋值name变量的那行代码”的重构。 我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。 你可以随意改变getTheFlag函数的内部实现，及其返回结果的类型，而不用修改main函数中的任何代码。 我们不显式地指定变量name的类型，使得它可以被赋予任何类型的值。也就是说，变量name的类型可以在其初始化时，由其他程序动态地确定。 没错，通过这种类型推断，你可以体验到动态类型编程语言所带来的一部分优势，即程序灵活性的明显提升。Go语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。 ⑤.变量的重声明是什么意思? 这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。 在Go语言中，代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。Go语言本身以及我们编写的代码共同形成了一个非常大的代码块，也叫全域代码块。 这主要体现在，只要是公开的全局变量，都可以被任何代码所使用。相对小一些的代码块是代码包，一个代码包可以包含许多子代码包，所以这样的代码块也可以很大。 接下来，每个源码文件也都是一个代码块，每个函数也是一个代码块，每个if语句、for语句、switch语句和select语句都是一个代码块。甚至，switch或select语句中的case子句也都是独立的代码块。 变量重声明：其含义是对已经声明过的变量再次声明。变量重声明的前提条件如下： 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。 变量的重声明只可能发生在某一个代码块中。 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量12var err errorn, err := io.WriteString(os.Stdout, &quot;Hello, everyone!\n&quot;) (3).程序实体的作用域 ①.程序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是Go语言在语言层面，依据代码块对程序实体作用域进行的定义。 包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。然而，这个颗粒度是比较粗的，我们往往需要利用代码块再细化程序实体的作用域。 重要的：一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里开始。 ②.如果一个变量与其外层代码块中的变量重名会出现什么状况？ 123456789var block = &quot;package&quot;func main() &#123; block := &quot;function&quot; &#123; block := &quot;inner&quot; fmt.Printf(&quot;The block is %s.\n&quot;, block) &#125; fmt.Printf(&quot;The block is %s.\n&quot;, block)&#125; 运行结果 12The block is inner.The block is function. 引用变量时如何选择： 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错了 ③.不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？ 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。 (4).怎样判断一个变量的类型？ ①.value, ok := interface{}(container).([]string) 类型断言表达式的语法形式是x.(T)，其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。 interface{}(container)：把container变量的值转换为空接口值 .([]string)：判断前者的类型是否为切片类型 []string。 变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。 如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。 如果没有ok，判断为false时，会发生异常，panic ②.interface{}代表空接口，任何类型都是它的实现类型。interface{}(x)。 为什么在关键字interface的右边还要加上这个东西？ 对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值[]string{}，以及空的字典值map[int]string{}。 ③.类型转换表达式：T(x)。 其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}），还可以是一个表达式。在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型。如果从源类型到目标类型的转换是不合法的，那么就会引发一个编译错误。那怎样才算合法？ 首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。 第二，虽然直接把一个整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换的结果将会是”�”（仅由高亮的问号组成的字符串值）。比如string(-1)，就是� 第三，关于string类型与各种切片类型之间的互转的。 一个值在从string类型向[]byte类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。string([]byte{&#39;\xe4&#39;, &#39;\xbd&#39;, &#39;\xa0&#39;, &#39;\xe5&#39;, &#39;\xa5&#39;, &#39;\xbd&#39;}) // 你好 一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个Unicode字符。string([]rune{&#39;\u4F60&#39;, &#39;\u597D&#39;}) // 你好 (5).什么是别名类型？什么是潜在类型？ ①.“别名类型”：type MyString = string，比如byte是uint8的别名类型，而rune是int32的别名类型。 ②.类型再定义：type MyString2 string // 注意，这里没有等号。MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。 ③.对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。潜在类型的含义是：某个类型在本质上是哪个类型，或者是哪个类型的集合。 ④.如果两个值潜在类型相同，却属于不同类型，它们之间是可以进行类型转换的。因此，MyString2类型的值与string类型的值，可以使用类型转换表达式进行互转。 ⑤.但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是MyString2和string。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>06.变量作用域</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.反射、并发]]></title>
    <url>%2F2019%2F08%2F11%2F5.%E5%8F%8D%E5%B0%84%E3%80%81%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1.反射reflection (1).反射可大大提高程序的灵活性，使得 interface{} 有更大的发挥余地 (2).反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息 1234567891011121314151617181920212223242526272829303132333435type User struct &#123; Id int Name string Age int&#125;func (u User) Hello() &#123; fmt.Println(&quot;hello world&quot;)&#125;func Info(o interface&#123;&#125;) &#123; t := reflect.TypeOf(o) fmt.Println(&quot;Type&quot;, t.Name()) v := reflect.ValueOf(o) fmt.Println(&quot;feilds:&quot;) for i := 0; i &lt; t.NumField(); i++ &#123; f := t.Field(i) value := v.Field(i).Interface() fmt.Printf(&quot;%6s: %v = %v\n&quot;, f.Name, f.Type, value) &#125; fmt.Println(&quot;method:&quot;) for i := 0; i &lt; t.NumMethod(); i++ &#123; m := t.Method(i) fmt.Printf(&quot;%6s: %v\n&quot;, m.Name, m.Type) &#125;&#125;func main() &#123; a := User&#123; Id: 15, Name: &quot;java&quot;, Age: 25, &#125; Info(a)&#125; (3).注意，在接口不能使用指针，如果要使用指正，首先通过reflect.Pro去判断，其次ValueOf返回后的变量需要取Elem方法 1234567891011121314151617func Set(o interface&#123;&#125;) &#123; v := reflect.ValueOf(o) //这里reflect的类型有Struct、Prt、String等 if v.Kind() == reflect.Ptr &amp;&amp; !v.Elem().CanSet() &#123; fmt.Println(&quot;XXX&quot;) &#125; else &#123; v = v.Elem() &#125; f := v.FieldByName(&quot;Name&quot;) if !f.IsValid() &#123; fmt.Println(&quot;Bad&quot;) return &#125; if f.Kind() == reflect.String &#123; f.SetString(&quot;hfeh&quot;) &#125;&#125; (4).通过指针操作字段(基本数据类型的操作) 1234x := 123v := reflect.ValueOf(&amp;x)v.Elem().SetInt(15154)fmt.Println(x) (5).通过反射可以“动态”调用方法 (6).反射会将匿名字段作为独立字段（匿名字段本质） (7).想要利用反射修改对象状态，前提是 interface.data 是 settable， 即 pointer-interface 2.并发编程 (1).Goroutine 奉行一个原则：通过通信来共享内存，而不是共享内存来通信!!!。 (2).Channel ①.Channel 是 goroutine 沟通的桥梁，大都是阻塞同步的 ②.Channel 是引用类型，通过 make 创建，close 关闭，可以使用 for range 来迭代不断操作 channel 定义的格式：make(chan channel的类型，缓存的大小)1234567891011121314func main() &#123; c := make(chan bool) go func() &#123; fmt.Println(&quot;GO GO GO !!!&quot;) //往channel中存入一个变量true c &lt;- true //关闭 close(c) &#125;() //for range会进行等待，必须在某个地方关闭channel for v := range c &#123; fmt.Println(v) &#125;&#125; ③.可以设置单向或双向通道 直接make是单向通道，又可以存，又可以取 ④.可以设置缓存大小，在未被填满前不会发生阻塞 有缓存的情况下类似 LinkedBlockingQueue 有缓存它是异步的，没有缓存它是同步阻塞的，但也不是绝对的，比如以下例子 123456789101112131415161718192021222324import ( &quot;fmt&quot; &quot;runtime&quot;)func main() &#123; //说明是启动了多线程 runtime.GOMAXPROCS(runtime.NumCPU()) c := make(chan bool, 10) for i := 0; i &lt; 10; i++ &#123; go Go(i, c) &#125; //这里类似countDownlatch for i := 0; i &lt; 10; i++ &#123; &lt;-c &#125;&#125;func Go(num int, c chan bool) &#123; a := 1 for i := 0; i &lt; 10; i++ &#123; a += i &#125; fmt.Println(num, a) c &lt;- true&#125; 第二种写法 1234567891011121314151617181920func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) wg := sync.WaitGroup&#123;&#125; wg.Add(10) c := make(chan bool, 10) for i := 0; i &lt; 10; i++ &#123; go Go(&amp;wg, c, i) &#125; wg.Wait()&#125;func Go(wg *sync.WaitGroup, c chan bool, num int) &#123; a := 1 for i := 0; i &lt; 10; i++ &#123; a += i &#125; fmt.Println(num, a) wg.Done()&#125; 没有缓存的情况下，类似TransferQueue 12345678910func main() &#123; //c是一个没有缓存的channel，类似TransferQueue c := make(chan bool) go func() &#123; fmt.Println(&quot;GO GO GO !!!&quot;) c &lt;- true &#125;() //这里取出操作&lt;-会一直阻塞，直到别的线程往里面存入了东西 fmt.Println(&lt;-c)&#125; (3).Select 可处理一个或多个 channel 的发送与接收 同时有多个可用的 channel时按随机顺序处理 可用空的 select 来阻塞 main 函数 可设置超时]]></content>
      <categories>
        <category>01.Golang</category>
        <category>05.反射、并发</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.函数]]></title>
    <url>%2F2019%2F08%2F11%2F4.%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在go语言中，一切皆是类型 1.函数function (1).Go 函数 不支持 嵌套、重载和默认参数 (2).但支持以下特性： 无需声明原型、不定长度变参、多返回值、命名返回值参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541.形参先变量名后类型，返回值写在后面应()包裹 func A( a int, b string) (int ,string)&#123; &#125;2.同类型参数 func A( a ,b,c string) int &#123; &#125;3.匿名返回值 func A() (int,int,int)&#123; a,b,c:=1,2,3 return a,b,c &#125; 或者 func A() (a, b, c int) &#123; a, b, c = 1, 2, 3 return a, b, c &#125;4.可变长度参数，它必须作为参数列表中最后一个参数，其实就是变成slicefunc A(a ...int) &#123;&#125;5.形参如果传入值就是值拷贝，如果引用，那么直接操作引用 传入值引用 func main() &#123; a, b, c := 1, 2, 3 A(a, b, c) fmt.Println(a, b, c) &#125; func A(a ...int) &#123; a[0] = 5 a[1] = 6 a[2] = 7 fmt.Println(a) &#125; 传入地址 func main() &#123; sl := []int&#123;1, 2, 3&#125; A(sl) fmt.Println(sl) &#125; func A(a []int) &#123; a[0] = 5 a[1] = 6 a[2] = 7 fmt.Println(a) &#125; 引用传递 func main() &#123; a := 1 A(&amp;a) fmt.Println(a) &#125; func A(a *int) &#123; *a = 5 fmt.Println(*a) &#125; 匿名函数、闭包 123456789101112131415161.匿名函数 a := func() &#123; fmt.Println(&quot;func a&quot;) &#125; a()2.闭包，闭包中使用的是地址引用，一个闭包相当于一个类，封装了引用 func main() &#123; f := closure(10) fmt.Println(f(1)) fmt.Println(f(2)) &#125; func closure(x int) func(y int) int &#123; return func(y int) int &#123; return x + y &#125; &#125; (3).定义函数使用关键字 func，且左大括号不能另起一行 (4).函数也可以作为一种类型使用 1234567func main() &#123; a := A a()&#125;func A() &#123; fmt.Println(&quot;func a&quot;)&#125; 2.defer (1).执行方式类似其它语言中的析构函数， (2).在函数体执行结束后,按照调用顺序的相反顺序逐个执行，这是它非常重要的特性 123456789for i := 0; i &lt; 3; i++ &#123; defer fmt.Println(i)&#125;这里首先生成了闭包了，闭包里面的i是个地址引用 for i := 0; i &lt; 3; i++ &#123; defer func() &#123; fmt.Println(i) &#125;()&#125; (3).即使函数发生严重错误也会执行 (4).支持匿名函数的调用 (5).常用于资源清理、文件关闭、解锁以及记录时间等操作 (6).通过与匿名函数配合可在return之后修改函数计算结果，如果函数体内某个变量作为defer时匿名函数的参数，则在定义defer时，即已经获得了拷贝，否则则是引用某个变量的地址 (7).Go 没有异常机制，但有 panic/recover 模式来处理错误Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效 3.结构struct (1).Go 中的struct与C中的struct非常相似，并且Go没有class (2).使用 type struct{} 定义结构，名称遵循可见性规则 可以使用字面值对结构进行初始化123456789101112131415type person struct &#123; Name string Age int&#125;func main() &#123; p := person&#123;&#125; p.Name = &quot;java&quot; p.Age = 16 或者字面值赋值 p := person&#123; Name: &quot;java&quot;, Age: 16 &#125; fmt.Println(p)&#125; (3).支持指向自身的指针类型成员 命名结构时一般都是取地址 允许直接通过指针来读写结构成员12345678910111213func main() &#123; p := &amp;person&#123; Name: &quot;java&quot;, Age: 16, &#125; p.Name = &quot;go&quot; A(p) fmt.Println(p)&#125;func A(p *person) &#123; p.Age = 25 fmt.Println(p)&#125; (4).支持匿名结构，可用作成员或定义成员变量 1234567891011121314151617181920212223p := &amp;struct &#123; Name string Age int&#125;&#123; Name: &quot;java&quot;, Age: 16,&#125;支持结构化嵌套type person struct &#123; Name string Age int Contact struct&#123; //这个就是为什么go把类型放在变量名之后的原因，非常方便 Phone,City string &#125;&#125;嵌套结构体的初始化p := &amp;person&#123; Name: &quot;java&quot;, Age: 16,&#125;p.Contact.Phone = &quot;18256236446&quot;p.Contact.City = &quot;hanghzou&quot; (5).支持匿名字段，本质上是定义了以某个类型名为名称的字段 12345type person struct &#123; string int&#125;p := person&#123;&quot;java&quot;, 16&#125; (6).相同类型的成员可进行直接拷贝赋值，支持 == 与 !=比较运算符，但不支持 &gt; 或 &lt; (7).在go语言中，使用组合而不是继承，来完成体系继承 123456789101112131415161718192021type human struct &#123; Sex string&#125;type teacher struct &#123; human Name string Age int&#125;type student struct &#123; human Name string Age int&#125;func main() &#123; t := teacher&#123;Name: &quot;java&quot;, Age: 19, human: human&#123;Sex: &quot;nan&quot;&#125;&#125; t.Sex = &quot;nv&quot; fmt.Println(t)&#125; 4.方法method (1).Go 中虽没有class，但依旧有method (2).通过显示说明receiver来实现与某个类型的组合 函数命名格式： func (需要链接的接受者变量及类型) 方法名(形参) (返回值变量以及类型) 只能为同一个包中的类型定义方法 Receiver 可以是类型的值或者指针 方法绑定的类型需要在同一个包下123456type A struct &#123; Name string&#125;func (a A) Print() &#123; fmt.Println(&quot;A method&quot;)&#125; (3).方法是和某个类型绑定的，如果绑定的类型不同，虽然函数名相同，也是不同的方法！！！不存在方法重载 (4).对象可以使用值或指针来调用方法，编译器会自动完成转换，很重要！ 如果在Receiver 上定义的是值传递，那么就是值拷贝 如果在Receiver 上定义的是指针，那么操作的就是指针 (5).通过上述方式可以为任何类型，扩展方法，甚至是底层数据类型。这种方式扩展性很强，有点面向对象的味道。注意，类型别名不会拥有底层类型所附带的方法，所以在使用过程中需要强制类型转换！。可以感觉到，java是自上而下的继承，而go是自下而上的继承 12345678910111213type TZ intfunc main() &#123; var a TZ a.Print()&#125;func (a *TZ) Print() &#123; fmt.Println(&quot;aaaaa&quot;)&#125;func (a *TZ) Increase(num int) &#123; //注意这里强制类型转换和java不同 *a += TZ(num)&#125; (6).从某种意义上来说，方法是函数的语法糖，因为receiver其实就是方法所接收的第1个参数（Method Value 和 Method Expression两者效果一直） 12341.Method Value a.Print()2.Method Expression，使用上有点类型反射(*TZ).Print(&amp;a) (7).如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法 (8).在go语言中，首字母大写是公开字段，首字母小写是非公开字段。和java一样，方法可以调用结构中的非公开字段 注意，在go，私有字段的范围是整个package，而不是struct，这个java不同 5.接口interface (1).接口是一个或多个方法签名的集合 1234type USB interface &#123; PrintName() string Connect()&#125; (2).只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示。go语言并不要显示的说你实现了哪些接口，只要你的方法集是某个接口的超级，那么你默认实现了这个接口 12345678910type PhoneConencter struct &#123; name string&#125;func (pc PhoneConencter) PrintName() string &#123; return pc.name&#125;func (pc PhoneConencter) Connect() &#123; fmt.Println(&quot;Connent&quot;, pc.name)&#125; (3).使用时只要运用“多态”就行，父类引用指向子类对象 123var a USBa = PhoneConencter&#123;name: &quot;PhoneConencter&quot;&#125;a.Connect() (4).接口可以匿名嵌入其它接口，或嵌入到结构中 1234567type USB interface &#123; PrintName() string Connecter&#125;type Connecter interface &#123; Connect()&#125; (5).接口只有方法声明，没有实现，没有数据字段 (6).父类引用向下强转，使用OK pattern或者更高效的使用switch 1234567891011121314151617ok patternfunc Disconnecter(usb USB) &#123; //insaneof和向下强转 if pc, ok := usb.(PhoneConencter); ok &#123; fmt.Println(&quot;disconnected&quot;, pc.name) return &#125; fmt.Println(&quot;unknown divice&quot;)&#125; ------------------------------------------------- 使用type---switchswitch v := usb.(type) &#123;case PhoneConencter: fmt.Println(&quot;disconnected&quot;, v.name)default: fmt.Println(&quot;unknown divice&quot;)&#125; (7).go语言中所有的类型的都实现了空接口，相当于Object 12type empty interface&#123;&#125; (8).接口也可实现类似OOP中的多态 只能自底向上转，接口多的转化为接口少的 只能从USB向Connect转化 (9).将对象赋值给接口时，会发生拷贝（在recieve中定义的形参对象），而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针 (10).只有当接口存储的类型和对象都为nil时，接口才等于nil (11).接口调用不会做receiver的自动转换 (12)接口同样支持匿名字段方法]]></content>
      <categories>
        <category>01.Golang</category>
        <category>04.函数</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.Go的控制语句、slice、map]]></title>
    <url>%2F2019%2F08%2F11%2F3.Go%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E3%80%81slice%E3%80%81map%2F</url>
    <content type="text"><![CDATA[1.if语句 (1).条件表达式没有括号 123 if 1 &lt; 2 &#123; fmt.Println(&quot;A&quot;)&#125; (2).支持一个初始化表达式（可以是并行方式） 123456a := 10if b:= 1,a:=1;a&gt;0 &#123; fmt.Println(a);&#125;fmt.Println(a);输出 1 10 (3).左大括号必须和条件语句或else在同一行 (4).支持单行模式 (5).初始化语句中的变量为block级别，同时隐藏外部同名变量 2.for语句 (1).在go语言中，只有for循环而没有while循环，但支持3种形式(将功能多样的多个关键字合并为同一个关键字) (2).初始化和步进表达式可以是多个值 (3).条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，尽量提前计算好条件并以变量或常量代替 (4).左大括号必须和条件语句在同一行 (5).死循环形式 1234567a := 1for &#123; a++ if a &gt; 3 &#123; break &#125;&#125; (6).带条件循环 1234a := 1for a &lt;= 3 &#123; a++&#125; (7).经典形式 1234567891011a := 1for i := 0; i &lt; 3; i++ &#123; a++&#125;并行方式赋值a := &quot;string&quot;b := 1for i, l := 0, len(a); i &lt; l; i++ &#123; b++&#125; 3.选择语句switch (1).可以使用任何类型或表达式作为条件语句 (2).不需要写break，一旦条件符合自动终止 (3).如希望继续执行下一个case，需使用fallthrough语句 (4).支持一个初始化表达式（可以是并行方式），右侧需跟分号 (5).左大括号必须和条件语句在同一行 (6).根据变量匹配 123456789a := 5switch a &#123;case 0: fmt.Println(&quot;a=0&quot;)case 1: fmt.Println(&quot;a=1&quot;)default: fmt.Println(&quot;None&quot;)&#125; (7).根据表达式匹配 12345678910a := 5switch &#123;case a &gt; 0: fmt.Println(&quot;a=0&quot;) fallthroughcase a &gt; 1: fmt.Println(&quot;a=1&quot;)default: fmt.Println(&quot;None&quot;)&#125; 4.跳转语句goto, break, continue (1).三个语法都可以配合标签使用 (2).标签名区分大小写，若不使用会造成编译错误 (3).Break与continue配合标签可用于多层循环的跳出 (4).Goto是调整执行位置，与其它2个语句配合标签的结果并不相同1234567lable:for &#123; for i := 0; i &lt; 3; i++ &#123; b++ break lable &#125;&#125; 5.数组Array (1).定义数组的格式：var [n]，n&gt;=0 12b := [5]int&#123;4: 2&#125;a := [...]int&#123;99: 2&#125; (2).数组长度也是类型的一部分，因此具有不同长度的数组为不同类型 (3).注意区分指向数组的指针和指针数组 数组指针,P是指向数组的指针 12b := [...]int&#123;99: 2&#125;var p *[100]int = &amp;b 指针数组，数组里全是指针,而不是数据的值 12x, y := 1, 2b := [...]*int&#123;&amp;x, &amp;y&#125; (4).数组在Go中为值类型（数组在java中是引用类型），数组在变量之间传递时，传递的数组的拷贝，而不是引用传递 (5).数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt; (6).可以使用new来创建数组，此方法返回一个指向数组的指针 123a := new([3]int)等价于pb := [...]int&#123;99: 2&#125;var p *[100]int = &amp;b (7).无论使用数组变量本身，还是指向数组变量的指针，都可以通过下标的方式直接访问元素 12345a := new([3]int)a[1] = 1b := [3]int&#123;&#125;b[1] = 1 (8).Go支持多维数组(非顶级元素不能设置为可变长度，这里和java不同)，}不能另一一行 12 a := [...][3]int&#123;&#123;1, 2, 3&#125;, &#123;1, 2&#125;&#125; (9).go语言版本的冒泡算法 12345678910111213141516171819a := [...]int&#123;5, 2, 1, 47, 454, 121, 121, 1&#125;fmt.Println(a)num := len(a)for i := 0; i &lt; num; i++ &#123; var flag = 0 for j := 0; j &lt; num-i-1; j++ &#123; if a[j] &lt; a[j+1] &#123; temp := a[j] a[j] = a[j+1] a[j+1] = temp flag++ &#125; &#125; if flag == 0 &#123; break &#125;&#125;fmt.Println(a) 6.切片slice (1).slice的声明 123456789101.声明一个slice中括号中既没有...,也没有数字var a []int2.截取数组成为一个slice，var a = [10]int&#123;&#125;s1 := a[5:10]//这里含头不含尾//取数组末尾5个元素s1 := a[5:]//取数组前5个元素s1 := a[:5] (2).其本身并不是数组，它指向底层的数组 (3).作为变长数组的替代方案，可以关联底层数组的局部或全部 (4).为引用类型 (5).可以直接创建或从底层数组获取生成 (6).使用len()获取元素个数，cap()获取容量 (7).一般使用make()创建,make([]T, len, cap) 其中cap可以省略，则和len的值相同 len表示存数的元素个数，cap表示容量 这个slice可以理解为一个动态数组，容量表示为系统一次性分配给slice多少空间，以后每次扩容时都在此区域进行，在MongoDB中有类似的思想，因为重新分配内存地址是一件效率很低的事情12s1 := make([]int, 3, 10)fmt.Println(len(s1), cap(s1)) (8).如果多个slice指向相同底层数组，其中一个的值改变会影响全部 (9).Reslice(需要从原slice的相对位置开始计数) Reslice时索引以被slice的切片为准 索引不可以超过被slice的切片的容量cap()值(原slice的cap从slice指针算起到结束) 索引越界不会导致底层数组的重新分配而是引发错误123s1 := make([]int, 3, 10)//重新slices2= s1[1:] (10).Append(slice中最重要的方法) 可以在slice尾部追加元素 可以将一个slice追加在另一个slice尾部 如果最终长度未超过追加到slice的容量则返回原始slice 如果超过追加到的slice的容量则将重新分配数组并拷贝原始数据( 只是将自身slice重新分配，不会影响原来共享的slice)1234s1 := make([]int, 3, 10)fmt.Printf(&quot;%p\n&quot;, s1)s1 = append(s1, 1, 2, 3, 4, 5, 6, 7)fmt.Printf(&quot;%v %p\n&quot;, s1, s1) (11).Copy copy(目标slice，源slice) 7.map (1).类似其它语言中的哈希表或者字典，以key-value形式存储数据 (2).Key必须是支持==或!=比较运算的类型，不可以是函数、map或slice (3).Map查找比线性搜索快很多，但比使用索引访问数据的类型慢100倍 (4).Map使用make()创建，支持 := 这种简写方式 make([keyType]valueType, cap)，cap表示容量，可省略 12345678第一种：使用&#123;&#125;初始化var m map[int]stringm = map[int]string&#123;&#125;第二种：使用make初始化var m map[int]stringm = make(map[int]string)第三种:直接使用类型推断m := make(map[int]string) 简单的存入和读取,，直接通过下标进行访问： 12m[1] = &quot;OK&quot;a := m[1] 键值对不存在时自动添加，使用delete(map变量名，下标值)删除某键值对 1delete(m, 1) (5).嵌套map必须层层初始化，类似多维数组 如何判断嵌套内层的map有没有被初始化，这时可以使用多返回值的优势：当只有一个返回值的时候，它会这个值value，当有两个返回值的返回值，第二返回值是一个boolean类型，表示该返回值是否存在。 对于嵌套map等数据类型，必须先检查后赋值！！！12345678var m map[int]map[int]stringm = make(map[int]map[int]string)a, flag := m[1][1]if !flag &#123; m[1] = make(map[int]string)&#125;m[1][1] = &quot;OK&quot;a, flag = m[1][1] (6).使用 for range 对map和slice进行迭代操作，for range 其实就是foreach，注意这里slice也可以看成是一个map 12345678910111213141516171819201.迭代slice或者mapfor i, v := range slice类型变量 &#123; 这里的i和v只是游标，不会改变实际值 如果要改变实际值，需要通过指针方式去获取：变量[i]&#125;for k, v := range map类型变量 &#123; 这里的i和v只是游标，不会改变实际值 如果要改变实际值，需要通过指针方式去获取：变量[i]&#125;2.例子：注意下面两者的区别sm := make([]map[int]string, 5)for _, v := range sm &#123; v = make(map[int]string) v[1] = &quot;OK&quot;&#125;for i := range sm &#123; sm[i] = make(map[int]string) sm[i][1] = &quot;OK&quot;&#125; (7).map是无序，但是可以间接进行排序。 123456789m := map[int]string&#123;1: &quot;a&quot;, 3: &quot;b&quot;, 2: &quot;c&quot;, 4: &quot;d&quot;, 5: &quot;e&quot;&#125;s := make([]int, len(m))i := 0for k, _ := range m &#123; s[i] = k i++&#125;sort.Ints(s)然后根据key，从map中取出值 (7).超出容量时会自动扩容，但尽量提供一个合理的初始值 (8).使用len()获取元素个数 (9).go语言版本的快速排序 12345678910111213141516171819202122quick_sort(a, 0, len(a)-1)func quick_sort(array []int, p int, r int) &#123; if p &gt;= r &#123; return &#125; q := pativion(array, p, r) quick_sort(array, p, q-1) quick_sort(array, q+1, r)&#125;func pativion(array []int, p int, r int) int &#123; pivot := array[r] i := p for j := p; j &lt; r; j++ &#123; if array[j] &lt; pivot &#123; swap(array, i, j) i++ &#125; &#125; swap(array, i, r) return i&#125;]]></content>
      <categories>
        <category>01.Golang</category>
        <category>03.Go的控制语句、slice、map</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.Go程序的一般结构]]></title>
    <url>%2F2019%2F08%2F11%2F2.Go%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1.一般结构 Go程序是通过 package 来组织的（与python类似），只有 package 名称为 main 的包可以包含 main 函数，一个可执行程序有且仅有 一个 main 包。 通过 import 关键字来导入其它非 main 包 通过 const 关键字来进行常量的定义 通过在函数体外部使用 var 关键字来进行全局变量的声明与赋值 通过 type 关键字来进行结构(struct)或接口(interface)的声明 通过 func 关键字来进行函数的声明 每个语句后面不需要有分号；，自动根据换行符结束(和JavaScript类似)，每次idea保存时自动格式化，取出句后的分号12345678910111213141516171819202122232425// 当前程序的包名package main// 导入其它的包import std &quot;fmt&quot;// 常量的定义const PI = 3.14// 全局变量的声明与赋值var name = &quot;gopher&quot;// 一般类型声明type newType int// 结构的声明type gopher struct&#123;&#125;// 接口的声明type golang interface&#123;&#125;// 由 main 函数作为程序入口点启动func main() &#123; std.Println(&quot;Hello world!你好，世界！&quot;)&#125; 2.细节 (1).Go导入 package 的格式 1234567import &quot;fmt&quot;import &quot;os&quot;可以简化为,注意为小括号，不是大括号import ( &quot;fmt&quot; &quot;os&quot;) 导入包之后，就可以使用格式.来对包中的函数进行调用 如果导入包之后，未调用其中的函数或者类型将会报出编译错误。 那么声明多个 常量、全局变量或一般类型（非接口、非结构）可以用上述方式。 (2).package 别名 当使用第三方包时，包名可能会非常接近或者相同，此时就可以使用别名来进行区别和调用1234import ( std &quot;io&quot;)std.Println(&quot;........&quot;) (3).可见性规则 Go语言中，使用 大小写 来决定该 常量、变量、类型、接口、结构，或函数 是否可以被外部包所调用。 根据约定，函数名首字母 小写 即为private 函数名首字母 大写 即为public 所以在引用第三方包的函数，首字母必定是大写的 3.基本类型 (1).布尔型：bool 长度：1字节 取值范围：true, false 注意事项：不可以用数字代表true或false (2).整型： int/uint 根据运行平台可能为32或64位 8位整型：int8/uint8 长度：1字节 取值范围：-128127/0255 16位整型：int16/uint16 长度：2字节 取值范围：-3276832767/065535 32位整型：int32（rune）/uint32 长度：4字节 取值范围：-2^32/22^32/2-1/02^32-1 64位整型：int64/uint64(相当于long) 长度：8字节 取值范围：-2^64/22^64/2-1/02^64-1 (3).字节型：byte（uint8别名） (4).浮点型：float32/float64(因为有float64，所以可以没有double) 长度：4/8字节 小数位：精确到7/15小数位 (5).复数：complex64/complex128 长度：8/16字节 足够保存指针的 32 位或 64 位整数型：uintptr (6).其它值类型： array(数组)、struct(结构)、string( 字符串) (7).引用类型： slice(切片，数组的高层封装)、map(哈希表)、chan(通道) (8).接口类型：inteface (9).函数类型：func( 为什么要有函数类型，因为函数可以赋值给变量的) 4.类型的零值 零值并不等于空值，而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0，bool为false，string为空字符串 声明变量后，如果没有人为赋值，编译器会给他一个值(保证数据的不会凭空出来) 5.类型别名 根据业务需求，可以将一种类型 声明成有意义的类型 比如 申明一个数据大小单位123 type (ByteSize int64 ) 6.单个变量的声明与赋值 变量的声明格式：var &lt;变量名称&gt; &lt;变量类型&gt; //方法体外声明变量 变量的赋值格式：&lt;变量名称&gt; = &lt;表达式&gt; //变量声明后的赋值 声明的同时赋值：var &lt;变量名称&gt; [变量类型] = &lt;表达式&gt; //强制类型转换，避免系统推测类型 赋值时省略类型，编译器可自动根据数值类型进行类型推断。 var a = 1 ==&gt; 自动推断 a 为int8 进一步进行简化：类似b:=1或者b:=false 这里冒号: 等价于关键字var 7.多个变量的声明与赋值 (1).规则： 全局变量的声明可使用 var() 的方式进行简写 全局变量的声明不可以省略 var，但可使用并行方式 所有变量都可以使用类型推断 局部变量不可以使用 var() 的方式简写，只能使用并行方式 (2).var()方式： 1234567var ( //使用常规方式，这里不能使用冒号， //因为冒好等同var，和外面的var重复，直接省略冒好即可 aaa = &quot;hello&quot; //使用并行的方式以及类型推断 sss,bbb = 1,2) (3).并行的方式 12var a,b,c,d int = 1,2,3,4e,f := 1,2 (4).:= 的正确使用姿势，当函数有多个返回值时使用！！！ 8.变量的类型转换 Go中不存在隐式转换，所有类型转换必须显式声明，这保证了Go语言是一种类型安全的语言！ 转换只能发生在两种相互兼容的类型之间 类型转换的格式： [:]= () 比如 b:=int(c) 如果b是一个未申明变量，需要使用：(:相当于关键字var) 如果b在前面已经做过声明，直接省略： 9.常量的定义 (1).一般规定 常量的值在编译时就已经确定,不能引用全局变量的值 常量的定义格式与变量基本相同 等号右侧必须是常量或者常量表达式 常量表达式中的函数必须是内置函数(len等) (2).常量的初始化规则与枚举 在定义常量组时，如果不提供初始值，则表示将使用上行的表达式 使用相同的表达式不代表具有相同的值 iota是常量的计数器，从0开始，组中每定义1个常量自动递增1 1234567 const (a int = 1b string = &quot;A&quot;c = iotad ) 输出 1 A 2 3 iota的值与它出现的顺序有关，与它出现的次序无关 通过初始化规则与iota可以达到枚举的效果 123456789101112 const ( Monday = iota Tuesday ...... ) ``` - 每遇到一个const关键字，iota就会重置为0 - (3).规范：一般常量为大写字母开头，中间可以加上下划线_ - 但是大写字母开头的东西都是Public的，所有可以在前面加上_或者小写字母c- ##### 10.运算符 - Go中的运算符均是从左至右结合 优先级（从高到低）^ ! （一元运算符） / % &lt;&lt; &gt;&gt; &amp; &amp;^ | ^ （二元运算符）== != &lt; &lt;= &gt;= &gt;&lt;- （专门用于channel）&amp;&amp;||1- 例子： 二进制 十进制 01100 12 10110 22 二元位运算符 二进制 十进制 逻辑 &amp; 00100 4 相同位的两个数字­都为1，则为1；若有一个不为1，则为0。 | 11110 30 相同位只要一个为1即为1。否则为0 ^ 11010 26 相同位不同为1则为1，否则为0。 &amp;^ 01000 8 如果第二个数是1，则强制把第一个数改成0，否则不变。 123456- ##### 11.指针 - Go虽然保留了指针，但与其它编程语言不同的是，在Go当中不支持指针运算以及”-&gt;”运算符，而直接采用”.”选择符来操作指针目标对象的成员 - 操作符”&amp;”取变量地址，使用”*”通过指针间接访问目标对象默认值为 nil 而非 NULL func main() { a := 1 var p int = &amp;a fmt.Println(p)}``` 11.递增递减语句 在Go中，++ 与 – 是作为语句而并不是作为表达式 即 ++或者– 不能出现= 号后边]]></content>
      <categories>
        <category>01.Golang</category>
        <category>02.Go程序的一般结构</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.环境搭建]]></title>
    <url>%2F2019%2F08%2F11%2F1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[1.下载 go语言包 网址上输入studygolang.com，点击下载，下载golang的版本 一般是goXXX版本windows-amd64.zip包 下载后放到本地一个位置，直接解压即可，比如E:\Program Files\go 2.配置环境变量 (1).添加系统环境变量GOROOT(语言包)、GOPATH(工作空间目录) (2).添加path，%GOROOT%\bin;%GOPATH%\bin; (3).工作空间中添加3个文件夹src、bin、pkg 3.简单命令 go version go(查看各种命令) go run：直接运行程序 go build：测试编译 go fmt：格式化源码(部分idea 保存时自动调用) go install： 编译包文件并编译整个程序 go test：运行测试文件 go doc：查看帮助文档 godoc -http=:8080(启动本地官网，输入http://localhost:8080) 4.程序整体结构 bin/ mathapp pkg/ 平台名/(比如window_amd64、linux_amd64) mymath.a(引用的包文件) src/ mathapp main.go mymath(引用包文件) 5.命令使用 运行过程分析：运行 go install 首先编译src下应用的包文件，在pkg中生成对应的.a文件，最后编译src下的main.go，在bin目录下生成.exe可执行文件。 生成后.exe文件后，.exe真正运行时，需要将.exe文件重新拷贝至 src目录下(exe与src文件存在相对路径)。 6.环境变量 (1).三个环境变量 GOROOT：Go语言安装根目录的路径，也就是GO语言的安装路径。 GOPATH：若干工作区目录的路径。是我们自己定义的工作空间。 GOBIN：GO程序生成的可执行文件（executable file）的路径。 (2). Go语言源码的组织方式 ①.Go语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的 ②.一个代码包中可以包含任意个以.go为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。 ③.每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。 1import &quot;github.com/labstack/echo&quot; ④.在工作区中，一个代码包的导入路径实际上就是从src子目录，到该包的实际存储位置的相对路径。 ⑤.Go语言的源码文件都需要被存放在环境变量GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中。 7.源码安装后的结果 (1).源码文件通常会被放在某个工作区的src子目录下。安装后如果产生了归档文件（以“.a”为扩展名的文件，这个文件解压后是一个代码包），就会放进该工作区的pkg子目录；如果产生了可执行文件，就可能会放进该工作区的bin子目录。 (2).归档文件存放的具体位置和规则。 ①.源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。 ②.比如，一个已存在的代码包的导入路径是 1github.com/labstack/echo 那么执行命令 1go install github.com/labstack/echo 生成的归档文件的相对目录就是 github.com/labstack 文件名为echo.a。上面这个代码包导入路径还有另外一层含义，那就是：该代码包的源码文件存在于GitHub网站的labstack组的代码仓库echo中。 ③.归档文件的相对目录与pkg目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。 上述代码包的归档文件就会被放置在当前工作区的子目录pkg/linux_amd64/github.com/labstack中。 8.构建和安装Go程序的过程 (1).构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。 (2).构建 如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。 如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。 (3).安装 安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。 如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的pkg目录下的某个子目录中。 如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的bin目录中，或者环境变量GOBIN指向的目录中。]]></content>
      <categories>
        <category>01.Golang</category>
        <category>01.环境搭建</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
</search>
