<!DOCTYPE html>





<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":true,"show_result":true,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="1.go中的编程哲学和并发编程模式 (1).Don’t communicate by sharing memory; share memory by communicating–不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。  ①.通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。 ②.gorouti">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="10.go的同步工具">
<meta property="og:url" content="https://lospark.github.io/2019/08/11/10.go的同步工具/index.html">
<meta property="og:site_name" content="Eirunye Activity">
<meta property="og:description" content="1.go中的编程哲学和并发编程模式 (1).Don’t communicate by sharing memory; share memory by communicating–不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。  ①.通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。 ②.gorouti">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://lospark.github.io/2019/08/11/10.go的同步工具/img1.png">
<meta property="og:image" content="https://lospark.github.io/2019/08/11/10.go的同步工具/img2.png">
<meta property="og:image" content="https://lospark.github.io/2019/08/11/10.go的同步工具/img3.png">
<meta property="og:updated_time" content="2019-08-18T15:00:35.033Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10.go的同步工具">
<meta name="twitter:description" content="1.go中的编程哲学和并发编程模式 (1).Don’t communicate by sharing memory; share memory by communicating–不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。  ①.通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。 ②.gorouti">
<meta name="twitter:image" content="https://lospark.github.io/2019/08/11/10.go的同步工具/img1.png">
  <link rel="canonical" href="https://lospark.github.io/2019/08/11/10.go的同步工具/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>10.go的同步工具 | Eirunye Activity</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Eirunye Activity</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Lospark的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">1</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">2</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">13</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-schedule">
      
    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>


  </div>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lospark.github.io/2019/08/11/10.go的同步工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lospark">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eirunye Activity">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">10.go的同步工具

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-08-11 13:27:27" itemprop="dateCreated datePublished" datetime="2019-08-11T13:27:27Z">2019-08-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-18 15:00:35" itemprop="dateModified" datetime="2019-08-18T15:00:35Z">2019-08-18</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/01-Golang/" itemprop="url" rel="index"><span itemprop="name">01.Golang</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/01-Golang/01-基础模块/" itemprop="url" rel="index"><span itemprop="name">01.基础模块</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><h5 id="1-go中的编程哲学和并发编程模式"><a href="#1-go中的编程哲学和并发编程模式" class="headerlink" title="1.go中的编程哲学和并发编程模式"></a>1.go中的编程哲学和并发编程模式</h5><ul>
<li><p>(1).Don’t communicate by sharing memory; share memory by communicating–不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据。</p>
<ul>
<li>①.通道（也就是channel）类型的值，可以被用来以通讯的方式共享数据。更具体地说，它一般被用来在不同的goroutine之间传递数据。</li>
<li>②.goroutine代表着并发编程模型中的用户级线程。</li>
</ul>
</li>
<li><p>(2).进程与线程</p>
<ul>
<li>①.进程，描述的就是程序的执行过程，是运行着的程序的代表。换句话说，<strong>一个进程其实就是某个程序运行时的一个产物</strong>。</li>
<li>②.线程。<ul>
<li>首先，线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。</li>
<li>一个进程至少会包含一个线程。<strong>如果一个进程只包含了一个线程，那么它里面的所有代码都只会被串行地执行</strong>。每个进程的第一个线程都会随着该进程的启动而被创建，它们可以被称为其所属进程的主线程。</li>
<li>相对应的，<strong>如果一个进程中包含了多个线程，那么其中的代码就可以被并发地执行</strong>。除了进程的第一个线程之外，其他的线程都是由进程中已存在的线程创建出来的。</li>
</ul>
</li>
<li>③.<strong>主线程之外的其他线程都只能由代码显式地创建和销毁</strong>。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我们下达这样的指令，它们只会忠实地执行我们的指令。</li>
<li>④.在Go程序当中，<strong>Go语言的运行时（runtime）系统会帮助我们自动地创建和销毁系统级的线程</strong>。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。</li>
</ul>
</li>
<li><p>(3).<strong>用户线程指的是架设在系统级线程之上的，由用户（或者说我们编写的程序）完全控制的代码执行流程</strong>。</p>
<ul>
<li>①.用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。</li>
<li>②.但是，劣势也是有的，最明显也最重要的一个劣势就是复杂。既是指令下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。</li>
</ul>
</li>
<li><p>(4).<strong>Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度器</strong></p>
<ul>
<li>①.这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：<strong>G（goroutine的缩写）、P（processor的缩写）和M（machine的缩写）</strong>。</li>
<li>②.其中的<strong>M指代的就是系统级线程。而P是一个中介，可以承载若干个G，且能够使这些G适时地与M进行对接，并得到真正运行</strong>。</li>
<li>③.从宏观上说，<strong>G和M由于P的存在可以呈现出多对多的关系</strong>。当一个正在与某个M对接并运行着的G，需要因某个事件（比如等待I/O或锁的解除）而暂停运行的时候，调度器总会及时地发现，并把这个G与那个M分离开，以释放计算资源供那些等待运行的G使用。</li>
<li>④.<strong>而当一个G需要恢复运行的时候，调度器又会尽快地为它寻找空闲的计算资源（包括M）并安排运行</strong>。另外，当M不够用时，调度器会帮我们向操作系统申请新的系统级线程，而当某个M已无用时，调度器又会负责把它及时地销毁掉。</li>
<li>⑤.正因为调度器帮助我们做了很多事，所以我们的Go程序才总是能高效地利用操作系统和计算机资源。程序中的所有goroutine也都会被充分地调度，其中的代码也都会被并发地运行，即使这样的goroutine有数以十万计，也仍然可以如此。<br><img src="/2019/08/11/10.go的同步工具/img1.png" alt="image.png"></li>
</ul>
</li>
<li><p>(5).<strong>什么是主goroutine，它与我们启用的其他goroutine有什么不同？</strong></p>
<ul>
<li>①.与一个进程总会有一个主线程类似，<strong>每一个独立的Go程序在运行时也总会有一个主goroutine</strong>。这个主goroutine会在Go程序的运行准备工作完成后被自动地启用，并不需要我们做任何手动的操作。</li>
<li>②.<strong>每条go语句一般都会携带一个函数调用，这个被调用的函数常常被称为go函数</strong>。而主goroutine的go函数就是那个作为程序入口的main函数。<ul>
<li>主goroutine的重要特性：<strong>一旦主goroutine中的代码（也就是main函数中的那些代码）执行完毕，当前的Go程序就会结束运行</strong>。</li>
</ul>
</li>
<li>③.go函数真正被执行的时间，总会与其所属的go语句被执行的时间不同。<strong>当程序执行到一条go语句的时候，Go语言的运行时系统，会先试图从某个存放空闲的G的队列中获取一个G（也就是goroutine），它只有在找不到空闲G的情况下才会去创建一个新的G</strong>。创建G的成本也是非常低的。</li>
<li>④.<strong>在拿到了一个空闲的G之后，Go语言运行时系统会用这个G去包装当前的那个go函数（或者说该函数中的那些代码），然后再把这个G追加到某个存放可运行的G的队列中</strong>。</li>
<li>⑤.<strong>这类队列中的G总是会按照先入先出的顺序，很快地由运行时系统内部的调度器安排运行</strong>。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时还是存在的。</li>
<li>⑥.例子,运行完成后，多数情况下什么也不会输出！主goroutine如果睡眠1s，打印出可能是10个10<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">  for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(6).<strong>怎样才能让主goroutine等待其他goroutine？</strong></p>
<ul>
<li>方案：sleep、sync.WaitGroup、chan(使用空结构体struct{}最为介质最合适，它占用的内存空间是0字节，实例struct{}{}共用一份内存)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">num := 10</span><br><span class="line">sign := make(chan struct&#123;&#125;, num)</span><br><span class="line">for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">  go func() &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    sign &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line">// 办法1。</span><br><span class="line">//time.Sleep(time.Millisecond * 500)</span><br><span class="line">// 办法2。</span><br><span class="line">for j := 0; j &lt; num; j++ &#123;</span><br><span class="line">  &lt;-sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(7).<strong>怎样让我们启用的多个goroutine按照既定的顺序运行？</strong></p>
<ul>
<li><p>①.我们只需要稍微改造一下for语句中的那个go函数，<strong>要让它接受一个int类型的参数，并在调用它的时候把变量i的值传进去</strong>。只有这样，<strong>Go语言才能保证每个goroutine都可以拿到一个唯一的整数。其原因与go函数的执行时机有关</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">  go func(i int) &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>②.建立自旋函数trigger ，让所有goroutine调用，按照 n == i 规定输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var count uint32</span><br><span class="line">trigger := func(i uint32, fn func()) &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">    if n := atomic.LoadUint32(&amp;count); n == i &#123;</span><br><span class="line">      fn()</span><br><span class="line">      atomic.AddUint32(&amp;count, 1)</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Nanosecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for i := uint32(0); i &lt; 10; i++ &#123;</span><br><span class="line">  go func(i uint32) &#123;</span><br><span class="line">    fn := func() &#123;</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    trigger(i, fn)</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">trigger(10, func() &#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(8).总结：go函数的实际执行顺序往往与其所属的go语句的执行顺序（或者说goroutine的启用顺序）不同，而且默认情况下的执行顺序是不可预知的。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="2-解读Process"><a href="#2-解读Process" class="headerlink" title="2.解读Process"></a>2.解读Process</h5><ul>
<li><p>(1).Go语言并发编程模型中的P，正是goroutine的数量能够数十万计的关键所在。<strong>P的数量意味着Go程序背后的运行时系统中，会有多少个用于承载可运行的G的队列存在。每一个队列都相当于一条流水线，它会源源不断地把可运行的G输送给空闲的M，并使这两者对接</strong>。</p>
<ul>
<li>①.G就是goroutine的缩写，可以被理解为Go语言自己实现的用户级线程。M即为machine的缩写，代表着系统级线程，或者说操作系统内核级别的线程。</li>
<li>②.一旦对接完成，被对接的G就真正地运行在操作系统的内核级线程之上了。<strong>每条流水线之间虽然会有联系，但都是独立运作的</strong>。</li>
<li>③.<strong>最大P数量就代表着Go语言运行时系统同时运行goroutine的能力，也可以被视为其中逻辑CPU的最大个数</strong>。</li>
</ul>
</li>
<li><p>(2).协程(Coroutine):</p>
<ul>
<li><p>①.特性</p>
<ul>
<li>轻量级线程、</li>
<li><strong>非抢占式多任务处理，由协程主动交出控制权</strong>：线程是抢占式多任务处理，即各个任务都是去抢CPU执行权，<strong>线程没有控制权</strong>，当前的线程的语句执行一半，都有可能把CPU掐掉去执行别的资源。但协程不一样，我什么时候交出控制权，是有我内部自己决定的。就是由于非抢占式，所以才能做到轻量级。因为，<strong>抢占式的化，线程需要存很多内容，保证上下文切换时，还能继续运行。非抢占式，只要处理其中几个点就可以了，对资源消耗少</strong></li>
<li>编译器、解析器、虚拟机层面的多任务。在go中，会把一个func编译成协程，在执行时，会有调度器来调度协程</li>
<li>多个协程可能在一个或者多个线程上运行：由调度器来决定<br><img src="/2019/08/11/10.go的同步工具/img2.png" alt="image.png"></li>
</ul>
</li>
<li><p>②.<strong>子程序(函数调用就是一个子程序)是协程的一个特例</strong></p>
<ul>
<li>协程是一个比子程序更加宽泛的概念。在普通函数调用过程中，控制权的转移是单向的</li>
<li>但是在协程中，主程序和子程序的控制权是可以来回转移切换，是两个对立任务，控制权可以相互转移<br><img src="/2019/08/11/10.go的同步工具/img3.png" alt="image.png"></li>
</ul>
</li>
<li><p>③.goroutine的定义：</p>
<ul>
<li><strong>任何函数只需要加上go就能送给调度器执行，调度器在合适点记性切换。这些点，我们不能完全进行控制。传统意义上协程，需要显示的将切换点表示出来</strong>。可以使用 -race来检测数据冲突</li>
<li><strong>goroutine可能存在的切换点(只是参考)：</strong><ul>
<li>IO，select</li>
<li>channel</li>
<li>等待锁</li>
<li>函数调用（有时）</li>
<li>runtime.Gosched()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="3-sync包"><a href="#3-sync包" class="headerlink" title="3.sync包"></a>3.sync包</h5><ul>
<li><p>(1).相比于Go语言宣扬的“用通讯的方式共享数据”，通过共享数据的方式来传递信息和协调线程运行的做法其实更加主流</p>
<ul>
<li>①.一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况。这种情况也被称为竞态条件（race condition），这往往会破坏共享数据的一致性。</li>
<li>②.共享数据的一致性代表着某种约定，即：多个线程对共享数据的操作总是可以达到它们各自预期的效果。</li>
</ul>
</li>
<li><p>(2).同步的用途有两个，<strong>一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块</strong>。</p>
<ul>
<li>①.一个线程在想要访问某一个共享资源的时候，需要先申请对该资源的访问权限，并且只有在申请成功之后，访问才能真正开始。而当线程对共享资源的访问结束时，它还必须归还对该资源的访问权限，若要再次访问仍需申请。</li>
<li>②.如果针对某个共享资源的访问令牌只有一块，那么在同一时刻，就最多只能有一个线程进入到那个区域，并访问到该资源。</li>
<li>③.<strong>多个并发运行的线程对这个共享资源的访问是完全串行的</strong>。只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个临界区（critical section），也就是我刚刚说的，由于要访问到资源而必须进入的那个区域。</li>
<li>④.临界区：它们可以是一个内含了共享数据的结构体及其方法，也可以是操作同一块共享数据的多个函数。临界区总是需要受到保护的，否则就会产生竞态条件。施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。</li>
</ul>
</li>
<li><p>(3).在Go语言中，可供我们选择的同步工具并不少。其中，<strong>最重要且最常用的同步工具当属互斥量（mutual exclusion，简称mutex）</strong></p>
<ul>
<li><p>①.sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line">_, err := writer.Write([]byte(data))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Printf(&quot;error: %s [%d]&quot;, err, id)</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>②.我们使用互斥锁时有哪些注意事项？我们总是应该保证，对于每一个锁定操作，都要<strong>有且只有一个</strong>对应的解锁操作。在很多时候，<strong>利用defer语句进行解锁可以更容易做到这一点</strong>。</p>
<ul>
<li><strong>不要重复锁定互斥锁</strong>：一个goroutine对某一个互斥锁的重复锁定，就意味着它自己锁死了自己。不能重入</li>
<li><strong>不要忘记解锁互斥锁，必要时使用defer语句</strong>：类似在finnaly中解锁</li>
<li>** 不要对尚未锁定或者已解锁的互斥锁解锁**：解锁未锁定的互斥锁会立即引发panic。</li>
<li><strong>不要在多个函数之间直接传递互斥锁</strong>：sync.Mutex类型的变量是一个<strong>结构体类型，属于值类型中的一种</strong>。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会<strong>导致它的副本的产生</strong>。并且，原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。如果你把一个互斥锁作为参数值传给了一个函数，<strong>那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响</strong>。</li>
<li>Go语言中的互斥锁是开箱即用的。换句话说，<strong>一旦我们声明了一个sync.Mutex类型的变量，就可以直接使用它了</strong>。</li>
</ul>
</li>
<li><p>③.读写锁<strong>sync.RWMutex</strong>与互斥锁有哪些异同？除了读读不阻塞之外，其余都是一样的。<strong>不要重复锁定、解锁或忘记解锁</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="4-条件变量sync-Cond"><a href="#4-条件变量sync-Cond" class="headerlink" title="4.条件变量sync.Cond"></a>4.条件变量sync.Cond</h5><ul>
<li><p>(1).条件变量：条件变量并不是被用来保护临界区和共享资源的，<strong>它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程</strong>。</p>
<ul>
<li>①.比如说，我们两个人在共同执行一项秘密任务，这需要在不直接联系和见面的前提下进行。我需要向一个信箱里放置情报，你需要从这个信箱中获取情报。这个信箱就相当于一个共享资源，而我们就分别是进行写操作的线程和进行读操作的线程。</li>
<li>②.如果我在放置的时候发现信箱里还有未被取走的情报，那就不再放置，而先返回。另一方面，如果你在获取的时候发现信箱里没有情报，那也只能先回去了。这就相当于写的线程或读的线程阻塞的情况。</li>
<li>③.如果信箱里有情报，而你却迟迟未取走，那我就需要每过一段时间带着新情报去检查一次，若发现信箱空了，我就需要及时地把新情报放到里面。另一方面，如果信箱里一直没有情报，那你也要每过一段时间去打开看看，一旦有了情报就及时地取走。这么做是可以的，但就是太危险了，很容易被敌人发现。</li>
<li>④.各自雇佣了一个不起眼的小孩儿。如果早上七点有一个戴红色帽子的小孩儿从你家楼下路过，那么就意味着信箱里有了新情报。另一边，如果上午九点有一个戴蓝色帽子的小孩儿从我家楼下路过，那就说明你已经从信箱中取走了情报。<strong>这两个戴不同颜色帽子的小孩儿就相当于条件变量，在共享资源的状态产生变化的时候，起到了通知的作用</strong>。</li>
</ul>
</li>
<li><p>(2).条件变量怎样与互斥锁配合使用？<strong>条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的</strong>。</p>
<ul>
<li><p>①.条件变量提供的方法有三个：<strong>等待通知（wait）、单发通知（signal）和广播通知（broadcast）</strong></p>
<ul>
<li>类似Java中：await、singal、singalAll</li>
</ul>
</li>
<li><p>②.我们在利用条件变量<strong>等待通知的时候，需要在它基于的那个互斥锁保护下进行</strong>(await需要在获取锁的情况下调用，调用后释放锁)。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。</p>
</li>
<li><p>③.与sync.Mutex类型和sync.RWMutex类型不同，sync.Cond类型并不是开箱即用的。<strong>我们只能利用sync.NewCond函数创建它的指针值。这个函数需要一个sync.Locker类型的参数值（互斥锁）</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lock sync.RWMutex</span><br><span class="line">sendCond := sync.NewCond(&amp;lock)</span><br><span class="line">recvCond := sync.NewCond(lock.RLocker())</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这里sendCond使用lock写锁（lock和unlock），recvCond使用lock的读锁(lock.RLocker()调用的是lock中的Rlock和RUnlock)</strong></li>
</ul>
</li>
<li><p>④.我，现在是一个goroutine（携带的go函数），想要适时地向信箱里放置情报并通知你，应该怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.Lock()</span><br><span class="line">for mailbox == 1 &#123; //用for是因为可能存在空唤醒、误报</span><br><span class="line">  sendCond.Wait()//这里会放锁</span><br><span class="line">&#125;</span><br><span class="line">mailbox = 1</span><br><span class="line">lock.Unlock()</span><br><span class="line">recvCond.Signal()//通知别人</span><br></pre></td></tr></table></figure>
</li>
<li><p>⑤.另一方面，你现在是另一个goroutine，想要适时地从信箱中获取情报，然后通知我。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.RLock()</span><br><span class="line">for mailbox == 0 &#123;</span><br><span class="line">  recvCond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">mailbox = 0</span><br><span class="line">lock.RUnlock()</span><br><span class="line">sendCond.Signal()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(3).<strong>条件变量的Wait方法做了什么？</strong></p>
<ul>
<li>①.条件变量的Wait方法主要做了四件事<ul>
<li>第一：<strong>把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中</strong>。</li>
<li>第二：<strong>解锁当前的条件变量基于的那个互斥锁(unlock)</strong>。</li>
<li>第三：<strong>让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个Wait方法的那行代码上</strong>。</li>
<li>第四：<strong>如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>(4).<strong>条件变量的Signal方法和Broadcast方法有哪些异同？</strong></p>
<ul>
<li>①条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的goroutine，而后者的通知却会唤醒所有为此等待的goroutine。<strong>条件变量的Wait方法总会把当前的goroutine添加到通知队列的队尾，而它的Signal方法总会从通知队列的队首开始查找可被唤醒的goroutine。所以，因Signal方法的通知而被唤醒的goroutine一般都是最早等待的那一个</strong>。</li>
<li>②.再次强调一下，与Wait方法不同，<strong>条件变量的Signal方法和Broadcast方法并不需要在互斥锁的保护下执行</strong>。</li>
<li>③.<strong>条件变量的通知具有即时性。也就是说，如果发送通知的时候没有goroutine为此等待，那么该通知就会被直接丢弃</strong>。在这之后才开始等待的goroutine只可能被后面的通知唤醒。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="5-原子操作"><a href="#5-原子操作" class="headerlink" title="5.原子操作"></a>5.原子操作</h5><ul>
<li><p>(1).原子操作：</p>
<ul>
<li>①.对于一个Go程序来说，Go语言运行时系统中的调度器，会恰当地安排其中所有的goroutine的运行。不过，<strong>在同一时刻，只可能有少数的goroutine真正地处于运行状态，并且这个数量是固定的</strong>。所以，为了公平起见，调度器总是会频繁地换上或换下这些goroutine。</li>
<li>②.换上的意思是，<strong>让一个goroutine由非运行状态转为运行状态，并促使其中的代码在某个CPU核心上执行</strong>。</li>
<li>③.换下的意思正好相反，即：<strong>使一个goroutine中的代码中断执行，并让它由运行状态转为非运行状态</strong>。这个中断的时机有很多，任何两条语句执行的间隙，甚至在某条语句执行的过程中都是可以的。即使这些语句在临界区之内也是如此。所以，我们说，<strong>互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）</strong>。</li>
<li>④.真正能够保证原子性执行的只有原子操作（atomic operation）。<strong>原子操作在进行的过程中是不允许中断的。在底层，这会由CPU提供芯片级别的支持，所以绝对有效。即使在拥有多CPU核心，或者多CPU的计算机系统中，原子操作的保证也是不可撼动的</strong>。</li>
<li>⑤.<strong>这使得原子操作可以完全地消除竞态条件，并能够绝对地保证并发安全性</strong>。并且，它的执行速度要比其他的同步工具<strong>快得多，通常会高出好几个数量级</strong>。不过，正是因为原子操作不能被中断，<strong>所以它需要足够简单，并且要求快速</strong>。因此，<strong>操作系统层面只对针对二进制位或整数的原子操作提供了支持</strong>。</li>
</ul>
</li>
<li><p>(2).sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？</p>
<ul>
<li>①.sync/atomic包中的函数可以做的原子操作有：<strong>加法（add）、比较并交换（compare and swap，简称CAS）、加载（load）、存储（store）和交换（swap）</strong>。</li>
<li>②.这些函数针对的数据类型并不多。但是，<strong>对这些类型中的每一个，sync/atomic包都会有一套函数给予支持</strong>。这些数据类型有：<strong>int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer</strong>。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。</li>
<li>③.此外，<strong>sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值</strong>。</li>
</ul>
</li>
<li><p>(3).<strong>原子操作函数的第一个参数值必须是指针类型</strong></p>
<ul>
<li>比如，atomic.AddInt32函数的第一个参数，不是int32而是*int32。<strong>因为原子操作函数需要的是被操作值的指针，而不是这个值本身；</strong></li>
<li><strong>unsafe.Pointer类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针</strong>。</li>
<li><strong>只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据</strong>。</li>
</ul>
</li>
<li><p>(4).<strong>用于原子加法操作的函数可以做原子减法</strong></p>
<ul>
<li><code>atomic.AddInt32</code>函数的第二个参数代表差量，它的类型是int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。</li>
<li>对于无符号类型的，比如<code>atomic.AddUint32</code>函数的第二个参数值可以这么给出：<code>^uint32(-N-1))</code></li>
</ul>
</li>
<li><p>(5).<strong>CAS操作的优势</strong></p>
<ul>
<li><p>①.在进行CAS操作的时候，函数会先判断被操作变量的当前值，是否与我们预期的旧值相等。如果相等，它就把新值赋给该变量，并返回true以表明交换操作已进行；否则就忽略交换操作，并返回false</p>
</li>
<li><p>②.<strong>CAS操作并不是单一的操作，而是一种操作组合</strong>。可以实现各种操作，比如自旋锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">  if atomic.CompareAndSwapInt32(&amp;num2, 10, 0) &#123;</span><br><span class="line">     fmt.Println(&quot;The second number has gone to zero.&quot;)</span><br><span class="line">     break</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * 500)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>③.这在效果上与互斥锁有些类似。<strong>不过，它们的适用场景是不同的。我们在使用互斥锁的时候，总是假设共享资源的状态会被其他的goroutine频繁地改变。— 悲观锁</strong></p>
</li>
<li><p>④.而for语句加CAS操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。<strong>这是一种更加乐观，或者说更加宽松的做法。—乐观锁</strong></p>
</li>
</ul>
</li>
<li><p>(6).假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？回答：很有必要。<strong>如果写操作还没有进行完，读操作就来读了，那么就只能读到仅修改了一部分的值。这显然破坏了值的完整性，读出来的值也是完全错误的</strong>。</p>
</li>
<li><p>(7).<strong>由于这里的原子操作函数只支持非常有限的数据类型，所以在很多应用场景下，互斥锁往往是更加适合的</strong>。</p>
</li>
<li><p>(8).sync/atomic.Value</p>
<ul>
<li>①.<strong>atomic.Value类型是开箱即用的，它只有两个指针方法——Store和Load</strong>。</li>
<li>②.一旦atomic.Value类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。<ul>
<li>读取值：atomic.Value类型属于结构体类型，而结构体类型属于值类型。复制该类型的值会产生一个完全分离的新值。</li>
<li>存储值，有两条强制性的使用规则。第一条规则，不能用原子值存储nil。这里要注意，如果有一个接口类型的变量，它的动态值是nil，但动态类型却不是nil，那么它的值就不等于nil，这样一个变量的值是可以被存入原子值的。第二条规则，<strong>我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>(9).具体的使用建议:</p>
<ul>
<li><strong>不要把内部使用的原子值暴露给外界</strong>。</li>
<li><strong>如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它</strong>。</li>
<li><strong>如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性</strong>。</li>
<li><strong>如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型</strong>。</li>
<li><strong>尽量不要向原子值中存储引用类型的值。因为这很容易造成安全漏洞</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="6-sync-WaitGroup"><a href="#6-sync-WaitGroup" class="headerlink" title="6.sync.WaitGroup"></a>6.sync.WaitGroup</h5><ul>
<li><p>(1).sync包的WaitGroup类型：<strong>它比通道更加适合实现这种一对多的goroutine协作流程</strong>。</p>
<ul>
<li>①.sync.WaitGroup类型（以下简称WaitGroup类型）是<strong>开箱即用</strong>的，也是并发安全的。同时，与我们前面讨论的几个同步工具一样，<strong>它一旦被真正使用就不能被复制了</strong>。</li>
<li>②.WaitGroup类型拥有三个指针方法：Add、Done和Wait。<strong>你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值</strong>。</li>
<li>③.一般情况下，我会用这个方法来记录需要等待的goroutine的数量。相对应的，<strong>这个类型的Done方法，用于对其所属值中计数器的值进行减一操作</strong>。我们可以在需要等待的goroutine中，<strong>通过defer语句调用它</strong>。</li>
<li>④.<strong>而此类型的Wait方法的功能是，阻塞当前的goroutine，直到其所属值中的计数器归零</strong>。如果在该方法被调用的时候，那个计数器的值就是0，那么它将不会做任何事情。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func coordinateWithWaitGroup() &#123;</span><br><span class="line">  var wg sync.WaitGroup</span><br><span class="line">  wg.Add(2)</span><br><span class="line">  num := int32(0)</span><br><span class="line">  fmt.Printf(&quot;The number: %d [with sync.WaitGroup]\n&quot;, num)</span><br><span class="line">  max := int32(10)</span><br><span class="line">  go addNum(&amp;num, 3, max, wg.Done)</span><br><span class="line">  go addNum(&amp;num, 4, max, wg.Done)</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">// addNum 用于原子地增加numP所指的变量的值。</span><br><span class="line">func addNum(numP *int32, id, max int32, deferFunc func()) &#123;</span><br><span class="line">  defer func() &#123;</span><br><span class="line">    deferFunc()</span><br><span class="line">  &#125;()</span><br><span class="line">  for i := 0; ; i++ &#123;</span><br><span class="line">    currNum := atomic.LoadInt32(numP)</span><br><span class="line">    if currNum &gt;= max &#123;</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">    newNum := currNum + 2</span><br><span class="line">    time.Sleep(time.Millisecond * 200)</span><br><span class="line">    if atomic.CompareAndSwapInt32(numP, currNum, newNum) &#123;</span><br><span class="line">      fmt.Printf(&quot;The number: %d [%d-%d]\n&quot;, newNum, id, i)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      fmt.Printf(&quot;The CAS operation failed. [%d-%d]\n&quot;, id, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(2).WaitGroup细节</p>
<ul>
<li>①.<strong>WaitGroup值是可以被复用的</strong>，但需要保证其计数周期的完整性。这里的计数周期指的是这样一个过程：该值中的计数器值由0变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了0。<ul>
<li><strong>如果一个此类值的Wait方法在它的某个计数周期中被调用，那么就会立即阻塞当前的goroutine，直至这个计数周期完成。在这种情况下，该值的下一个计数周期，必须要等到这个Wait方法执行结束之后，才能够开始</strong>。</li>
</ul>
</li>
<li>②.两种情况下引发panic<ul>
<li><strong>如果我们对它的Add方法的首次调用，与对它的Wait方法的调用是同时发起的</strong>，比如，在同时启用的两个goroutine中，分别调用这两个方法，<strong>那么就有可能会让这里的Add方法抛出一个panic</strong>。所以，<strong>虽然WaitGroup值本身并不需要初始化，但是尽早地增加其计数器的值，还是非常有必要的</strong>。</li>
<li>如果在一个此类值的Wait方法被执行期间，跨越了两个计数周期，那么就会引发一个panic。在当前的goroutine因调用此类值的Wait方法，而被阻塞的时候，另一个goroutine调用了该值的Done方法，并使其计数器的值变为了0。这会唤醒当前的goroutine，并使它试图继续执行Wait方法中其余的代码。上述过程是正常的，<strong>但在这时，又有一个goroutine调用了它的Add方法，并让其计数器的值又从0变为了某个正整数。此时，这里的Wait方法就会立即抛出一个panic</strong>。</li>
</ul>
</li>
<li>③.WaitGroup值的使用禁忌：<strong>不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的goroutine中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行！！！，非常重要</strong>。</li>
<li>④.在使用WaitGroup值的时候，我们最好用<strong>“先统一Add，再并发Done，最后Wait”</strong>的标准模式来构建协作流程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">for i := 1; i &lt;= total; i = i + stride &#123;</span><br><span class="line">  wg.Add(stride)</span><br><span class="line">  for j := 0; j &lt; stride; j++ &#123;</span><br><span class="line">    go addNum(&amp;num, i+j, wg.Done)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;End.&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="7-sync-Once"><a href="#7-sync-Once" class="headerlink" title="7.sync.Once"></a>7.sync.Once</h5><ul>
<li><p>(1).与sync.WaitGroup类型一样，sync.Once类型（以下简称Once类型）也<strong>属于结构体类型</strong>，同样也是<strong>开箱即用</strong>和并发安全的。由于这个类型中包含了一个sync.Mutex类型的字段，所以，<strong>复制该类型的值也会导致功能的失效</strong>。</p>
</li>
<li><p>(2).Once类型的Do方法只接受一个参数，这个参数的类型必须是func()。<strong>只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数</strong>。如果你有多个只需要执行一次的函数，那么就应该为<strong>它们中的每一个都分配一个sync.Once类型的值</strong></p>
</li>
<li><p>(3).Once类型中还有一个名叫done的uint32类型的字段。<strong>它的作用是记录其所属值的Do方法被调用的次数</strong>。不过，该字段的值只可能是0或者1。一旦Do方法的首次调用完成，它的值就会从0变为1。</p>
</li>
<li><p>(4).既然done字段的值不是0就是1，那为什么还要使用需要四个字节的uint32类型呢？原因很简单，<strong>因为对它的操作必须是“原子”的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (o *Once) Do(f func()) &#123;</span><br><span class="line">  if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // Slow-path.</span><br><span class="line">  o.m.Lock()</span><br><span class="line">  defer o.m.Unlock()</span><br><span class="line">  if o.done == 0 &#123;</span><br><span class="line">    defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">    f()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>①.Do方法在一开始就会通过调用atomic.LoadUint32函数来获取该字段的值，并且一旦发现该值为1就会直接返回。这也初步保证了“Do方法，只会执行首次被调用时传入的函数”。不过，单凭这样一个判断的保证是不够的。因为，<strong>如果有两个goroutine都调用了同一个新的Once值的Do方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为false而继续执行Do方法中剩余的代码</strong>。</li>
<li>②.在这个条件判断之后，Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，<strong>它会在临界区中再次检查done字段的值</strong>，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把done的值变为1。类似单例模式的双重检测机制。<strong>它们都会先在临界区之外判断一次关键条件，若条件不满足则立即返回。这通常被称为“快路径”，或者叫做“快速失败路径”。</strong></li>
<li>③.别看Do方法中的代码不多，<strong>但它却应用了一个很经典的编程范式。我们在Go语言及其标准库中，还能看到不少这个经典范式及它衍生版本的应用案例</strong>。</li>
</ul>
</li>
<li><p>(5).<strong>Do方法在功能方面的两个特点</strong>。</p>
<ul>
<li>①.第一个特点，由于Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，<strong>如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关goroutine的同时阻塞。</strong><ul>
<li>例如，有多个goroutine并发地调用了同一个Once值的Do方法，并且传入的函数都会一直执行而不结束。那么，这些goroutine就都会因调用了这个Do方法而阻塞。因为，除了那个抢先执行了参数函数的goroutine之外，其他的goroutine都会被阻塞在锁定该Once值的互斥锁m的那行代码上。</li>
</ul>
</li>
<li>②.Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且，这一操作是被挂在defer语句中的。<strong>因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1，即使是panic了也是如此</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="8-context"><a href="#8-context" class="headerlink" title="8.context"></a>8.context</h5><ul>
<li><p>(1).Context类型：它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。<strong>Context类型可以提供一类代表上下文的值</strong>。此类值是并发安全的，也就是说它可以被传播给多个goroutine。Context类型的值（以下简称Context值）是可以繁衍的，这意味着我们可以<strong>通过一个Context值产生出任意个子值</strong>。这些子值可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。</p>
<ul>
<li>①.<strong>所有的Context值共同构成了一颗代表了上下文全貌的树形结构</strong>。</li>
<li>②.这棵树的树根（或者称上下文根节点）是一个已经在context包中预定义好的Context值，它是全局唯一的。通过调用context.Background函数，我们就可以获取到它。这个上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能。也就是说，<strong>它既不可以被撤销（cancel），也不能携带任何数据</strong>。</li>
</ul>
</li>
<li><p>(2).除此之外，context包中还包含了四个用于繁衍Context值的函数，即：<strong>WithCancel、WithDeadline、WithTimeout和WithValue</strong>。</p>
<ul>
<li>①.这些函数的<strong>第一个参数的类型都是context.Context</strong>，而名称都为parent。顾名思义，<strong>这个位置上的参数对应的都是它们将会产生的Context值的父值</strong>。</li>
<li>②.WithCancel函数用于产生一个可撤销的parent的子值。</li>
<li>③.WithDeadline函数和WithTimeout函数则都可以被用来产生一个会定时撤销的parent的子值。</li>
<li>④.WithValue函数，我们可以通过调用它，产生一个会携带额外数据的parent的子值</li>
</ul>
</li>
<li><p>(3).<strong>“可撤销的”在context包中代表着什么？“撤销”一个Context值又意味着什么</strong>？</p>
<ul>
<li><p>①.Context类型：Done方法会返回一个元素类型为struct{}的接收通道。<strong>这个接收通道的用途并不是传递元素值，而是让调用方去感知“撤销”当前Context值的那个信号</strong>。</p>
</li>
<li><p>②.一旦当前的Context值被撤销，这里的接收通道就会被立即关闭。我们都知道，<strong>对于一个未包含任何元素值的通道来说，它的关闭会使任何针对它的接收操作立即结束</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func coordinateWithContext() &#123;</span><br><span class="line">  total := 12</span><br><span class="line">  var num int32</span><br><span class="line">  fmt.Printf(&quot;The number: %d [with context.Context]\n&quot;, num)</span><br><span class="line">  cxt, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">  for i := 1; i &lt;= total; i++ &#123;</span><br><span class="line">    go addNum(&amp;num, i, func() &#123;</span><br><span class="line">      if atomic.LoadInt32(&amp;num) == int32(total) &#123;</span><br><span class="line">        cancelFunc()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;-cxt.Done()</span><br><span class="line">  fmt.Println(&quot;End.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>③.除了让Context值的使用方感知到撤销信号，还能让它们得到“撤销”的具体原因。后者即是Context类型的Err方法的作用。<strong>该方法的结果是error类型的，并且其值只可能等于context.Canceled变量的值，或者context.DeadlineExceeded变量的值。前者用于表示手动撤销，而后者则代表：由于我们给定的过期时间已到，而导致的撤销。</strong></p>
</li>
<li><p>④.<strong>对于Context值来说，“撤销”这个词如果当名词讲，指的其实就是被用来表达“撤销”状态的信号；如果当动词讲，指的就是对撤销信号的传达</strong>；</p>
</li>
<li><p>⑤.当我们通过调用context.WithCancel函数产生一个可撤销的Context值时，<strong>还会获得一个用于触发撤销信号的函数</strong>。通过调用这个函数，我们就可以触发针对这个Context值的撤销信号。<strong>一旦触发，撤销信号就会立即被传达给这个Context值，并由它的Done方法的结果值（一个接收通道）表达出来</strong>。</p>
</li>
<li><p>⑥.<strong>撤销函数只负责触发信号，而对应的可撤销的Context值也只负责传达信号</strong>，它们都不会去管后边具体的“撤销”操作。实际上，我们的代码可以在感知到撤销信号之后，进行任意的操作。</p>
</li>
<li><p>⑦.这里的“撤销”最原始的含义其实就是，<strong>终止程序针对某种请求（比如HTTP请求）的响应，或者取消对某种指令（比如SQL指令）的处理。这也是Go语言团队在创建context代码包，和Context类型时的初衷</strong>。</p>
</li>
</ul>
</li>
<li><p>(4).<strong>撤销信号是如何在上下文树中传播的</strong>？</p>
<ul>
<li>①.在撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法会返回的那个通道。</li>
<li>②.然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个Context值会断开它与其父值之间的关联。</li>
<li>③.我们通过调用context包的WithDeadline函数或者WithTimeout函数生成的Context值也是可撤销的。它们不但可以被手动撤销，还会依据在生成时被给定的过期时间，自动地进行定时撤销。这里定时撤销的功能是借助它们内部的计时器来实现的。</li>
</ul>
</li>
<li><p>(5).<strong>怎样通过Context值携带数据？怎样从中获取数据？</strong></p>
<ul>
<li>①.WithValue函数在产生新的Context值（以下简称含数据的Context值）的时候需要三个参数，即：<strong>父值、键和值</strong>。与“字典对于键的约束”类似，这里键的类型必须是可判等的。</li>
<li>②.当我们从中获取数据的时候，它需要根据给定的键来查找对应的值。不过，这种Context值并不是用字典来存储键和值的，后两者只是被简单地存储在前者的相应字段中而已。</li>
<li>③.<strong>Context类型的Value方法就是被用来获取数据的</strong>。在我们调用含数据的Context值的Value方法时，它会先判断给定的键，是否与当前值中存储的键相等，如果相等就把该值中存储的值直接返回，否则就到其父值中继续查找。</li>
<li>④.如果其父值中仍然未存储相等的键，那么该方法就会沿着上下文根节点的方向一路查找下去。注意，除了含数据的Context值以外，其他几种Context值都是无法携带数据的。因此，Context值的Value方法在沿路查找的时候，会直接跨过那几种值。</li>
<li>⑤.如果我们调用的Value方法的所属值本身就是不含数据的，那么实际调用的就将会是其父辈或祖辈的Value方法。<strong>这是由于这几种Context值的实际类型，都属于结构体类型，并且它们都是通过“将其父值嵌入到自身”，来表达父子关系的</strong>。</li>
<li>⑥.Context接口并没有提供改变数据的方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="9-sync-Pool"><a href="#9-sync-Pool" class="headerlink" title="9.sync.Pool"></a>9.sync.Pool</h5><ul>
<li><p>(1).sync.Pool类型可以被称为临时对象池，它的值可以被用来存储临时的对象。<strong>sync.Pool类型也属于结构体类型，它的值在被真正使用之后，就不应该再被复制了</strong>。</p>
<ul>
<li>①.临时对象”的意思是：不需要持久使用的某一类值。<strong>这类值对于程序来说可有可无，但如果有的话会明显更好</strong>。它们的创建和销毁可以在任何时候发生，并且完全不会影响到程序的功能。同时，<strong>它们也应该是无需被区分的，其中的任何一个值都可以代替另一个</strong>。如果你的某类值完全满足上述条件，那么你就可以把它们存储到临时对象池中。</li>
<li>②.<strong>我们可以把临时对象池当作针对某种数据的缓存来用</strong>。</li>
<li>③.sync.Pool类型只有两个方法——Put和Get。接收和返回interface{}类型的数据。</li>
<li>③.Get方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的New字段创建一个新值，并直接将其返回。</li>
<li>④.sync.Pool类型的New字段代表着创建临时对象的函数。Get方法如果到了最后，仍然无法获取到一个值，那么就会调用该函数。该函数的结果值并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方。</li>
<li>⑤.sync.Pool并不是开箱即用的，需要先为Pool指定New字段对应的函数。比如fmt包中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ppFree = sync.Pool&#123;</span><br><span class="line">  New: func() interface&#123;&#125; &#123; return new(pp) &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(2).为什么说临时对象池中的值会被及时地清理掉？</p>
<ul>
<li><p>①.Go语言运行时系统中的垃圾回收器，所以在每次开始执行之前，都会对所有已创建的临时对象池中的值进行全面地清除。</p>
</li>
<li><p>②.sync包在被初始化的时候，会向Go语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。一旦池清理函数被注册到了Go语言运行时系统，后者在每次即将执行垃圾回收时就都会执行前者。</p>
</li>
<li><p>③.在sync包中还有一个包级私有的全局变量。这个变量代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为*sync.Pool的切片。我们可以称之为池汇总列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">  allPoolsMu Mutex</span><br><span class="line">  allPools   []*Pool</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>④.通常，在一个临时对象池的Put方法或Get方法第一次被调用的时候，这个池就会被添加到池汇总列表中。正因为如此，池清理函数总是能访问到所有正在被真正使用的临时对象池。更具体地说，<strong>池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列表都销毁掉</strong>。</p>
</li>
<li><p>⑤.最后，池清理函数会把池汇总列表重置为空的切片。如此一来，这些池中存储的临时对象就全部被清除干净了。</p>
</li>
</ul>
</li>
<li><p>(3).临时对象池存储值所用的数据结构是怎样的？</p>
<ul>
<li><p>①.在临时对象池中，有一个多层的数据结构。正因为有了它的存在，临时对象池才能够非常高效地存储大量的值。<strong>这个数据结构的顶层，我们可以称之为本地池列表，不过更确切地说，它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同</strong>。P存在的一个很重要的原因是为了分散并发程序的执行压力，而让临时对象池中的本地池列表的长度与P的数量相同的主要原因也是分散压力。这里所说的压力包括了存储和性能两个方面。</p>
</li>
<li><p>②.在本地池列表中的每个本地池都包含了三个字段：存储私有临时对象的字段private、代表了共享临时对象列表的字段shared，以及一个sync.Mutex类型的嵌入字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type poolLocalInternal struct &#123;</span><br><span class="line">  private interface&#123;&#125;   // Can be used only by the respective P.</span><br><span class="line">  shared  []interface&#123;&#125; // Can be used by any P.</span><br><span class="line">  Mutex                 // Protects shared.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>③.实际上，<strong>每个本地池都对应着一个P</strong>。我们都知道，一个goroutine要想真正运行就必须先与某个P产生关联。也就是说，<strong>一个正在运行的goroutine必然会关联着某个P</strong>。</p>
</li>
<li><p>④.在程序调用临时对象池的Put方法或Get方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的goroutine关联的那个P的ID。换句话说，一个临时对象池的Put方法或Get方法会获取到哪一个本地池，完全取决于调用它的代码所在的goroutine关联的那个P。</p>
</li>
</ul>
</li>
<li><p>(4).临时对象池是怎样利用内部数据结构来存取值的？</p>
<ul>
<li>①.<strong>临时对象池的Put方法总会先试图把新的临时对象，存储到对应的本地池的private字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值</strong>。只有当这个private字段已经存有某个值时，该方法才会去访问本地池的shared字段。</li>
<li>②.相应的，临时对象池的Get方法，总会先试图从对应的本地池的private字段处获取一个临时对象。只有当这个private字段的值为nil时，它才会去访问本地池的shared字段。</li>
<li>③.<strong>一个本地池的shared字段原则上可以被任何goroutine中的代码访问到，不论这个goroutine关联的是哪一个P</strong>。这也是我把它叫做共享临时对象列表的原因。相比之下，<strong>一个本地池的private字段，只可能被与之对应的那个P所关联的goroutine中的代码访问到</strong>，所以可以说，它是P级私有的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><h5 id="10-并发安全字典sync-Map"><a href="#10-并发安全字典sync-Map" class="headerlink" title="10.并发安全字典sync.Map"></a>10.并发安全字典sync.Map</h5><ul>
<li><p>(1).这个字典类型提供了一些常用的键值存取操作方法，并保证了这些操作的并发安全。同时，<strong>它的存、取、删等操作都可以基本保证在常数时间内执行完毕。换句话说，它们的算法复杂度与map类型一样都是O(1)的</strong>。</p>
<ul>
<li>①.与单纯使用原生map和互斥锁的方案相比，使用sync.Map可以显著地减少锁的争用。sync.Map本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。</li>
<li>②.无论在何种场景下使用sync.Map，我们都需要注意，与原生map明显不同，<strong>它只是Go语言标准库中的一员，而不是语言层面的东西</strong>。也正因为这一点，Go语言的编译器并不会对它的键和值进行特殊的类型检查。</li>
</ul>
</li>
<li><p>(2).并发安全字典对键的类型有要求吗？键的实际类型不能是<strong>函数类型、字典类型和切片类型</strong>。可以先通过调用reflect.TypeOf函数得到一个键值对应的反射类型值（即：reflect.Type类型的值），然后再调用这个值的Comparable方法，得到确切的判断结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if !reflect.TypeOf(key).Comparable() &#123;</span><br><span class="line">  panic(&quot;key is not comparable&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(3).怎样保证并发安全字典中的键和值的类型正确性？</p>
<ul>
<li>使用反射进行判断，但是反射浪费性能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type ConcurrentMap struct &#123;</span><br><span class="line">m         sync.Map</span><br><span class="line">keyType   reflect.Type</span><br><span class="line">valueType reflect.Type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cMap *ConcurrentMap) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;</span><br><span class="line">if reflect.TypeOf(key) != cMap.keyType &#123;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br><span class="line">return cMap.m.Load(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>(4).并发安全字典如何做到尽量避免使用锁</p>
<ul>
<li><p>①.sync.Map类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的map作为存储介质:read和 dirty</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Map struct &#123;</span><br><span class="line">  mu Mutex</span><br><span class="line"></span><br><span class="line">  read atomic.Value // readOnly</span><br><span class="line"></span><br><span class="line">  dirty map[interface&#123;&#125;]*entry</span><br><span class="line">  </span><br><span class="line">  misses int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>②.read字段是sync/atomic.Value类型的。可看作一个快照，它总会在条件满足时，去重新保存所属的sync.Map值中包含的所有键值对。它的只读特性只是对于其中键的集合而言的，它虽然不会增减其中的键，但却允许变更其中的键所对应的值.</p>
<ul>
<li>sync.Map在替换只读字典的时候根本用不着锁。另外，这个只读字典在存储键值对的时候，还在值之上封装了一层。<strong>它先把值转换为了unsafe.Pointer类型的值，然后再把后者封装，并储存在其中的原生字典</strong>中。如此一来，<strong>在变更某个键所对应的值的时候，就也可以使用原子操作了</strong>。</li>
</ul>
</li>
<li><p>③.dirty：它存储键值对的方式与read字段中的原生字典一致。<strong>脏字典和只读字典如果都存有同一个键值对，那么这里的两个键指的肯定是同一个基本值，这两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。</strong></p>
<ul>
<li>sync.Map在查找指定的键所对应的值的时候，<strong>总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定“只读字典中没有，但脏字典中可能会有这个键”的时候，它才会在锁的保护下去访问脏字典</strong>。  </li>
</ul>
</li>
<li><p>④.sync.Map在存储键值对的时候，<strong>只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。否则，它才会在锁的保护下把键值对存储到脏字典中</strong>。</p>
</li>
<li><p>⑤.顺便说一句，<strong>只有当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除</strong>。</p>
</li>
<li><p>⑥.这种情况会在重建脏字典以后的一段时间内出现。不过，过不了多久，它们就会被真正删除掉。在查找和遍历键值对的时候，已被逻辑删除的键值对永远会被无视。</p>
</li>
<li><p>⑦.对于删除键值对，sync.Map会先去检查只读字典中是否有对应的键。如果没有，脏字典中可能有，那么它就会在锁的保护下，试图从脏字典中删掉该键值对。</p>
</li>
<li><p>⑧.最后，sync.Map会把该键值对中指向值的那个指针置为nil，这是另一种逻辑删除的方式。</p>
</li>
<li><p>⑨.只读字典和脏字典之间是会互相转换的。在脏字典中查找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read字段中，然后把代表脏字典的dirty字段的值置为nil。在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。理所当然，这些转换操作肯定都需要在锁的保护下进行。</p>
</li>
</ul>
</li>
<li><p>(5).sync.Map的只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同。</p>
<ul>
<li>①.由于只读字典中键的集合不能被改变，所以其中的键值对有时候可能是不全的。相反，<strong>脏字典中的键值对集合总是完全的，并且其中不会包含已被逻辑删除的键值对</strong>。</li>
<li>②.在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。</li>
<li>③.在写操作中，新增键值对影响 &gt; 删除操作 &gt; 修改操作</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/go/" rel="tag"># go</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/08/11/09.go的数据类型/" rel="next" title="09.go的数据类型">
                  <i class="fa fa-chevron-left"></i> 09.go的数据类型
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/08/11/11.错误以及处理/" rel="prev" title="11.错误以及处理">
                  11.错误以及处理 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/head.jpg"
      alt="lospark">
  <p class="site-author-name" itemprop="name">lospark</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="https://github.com/lospark" title="GitHub &rarr; https://github.com/lospark" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
    
      <span class="links-of-author-item">
      
      
      
        
      
        <a href="mailto:786834592@qq.com" title="E-Mail &rarr; mailto:786834592@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
    
  </div>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lospark</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/affix.js?v=7.3.0"></script>
  <script src="/js/schemes/pisces.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  















  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
